[
	{
		"name": "code-narrator.config.ts",
		"path": "code-narrator.config.ts",
		"folderPath": "./",
		"fileContent": "// code-narrator.config.ts\r\nimport ConfigurationBuilder from \"./src/documentation/plugins/builders/Configuration/ConfigurationBuilder\";\r\nimport FilesBuilder from \"./src/documentation/plugins/builders/Files/FilesBuilder\";\r\nimport FoldersBuilder from \"./src/documentation/plugins/builders/Folders/FoldersBuilder\";\r\nimport ReadMeBuilder from \"./src/documentation/plugins/builders/ReadMe/ReadMeBuilder\";\r\nimport BehaviourBuilder from \"./src/documentation/plugins/builders/Behaviour/BehaviourBuilder\";\r\nimport DocusaurusGenerator from \"./src/documentation/plugins/generators/Docusaurus/DocusaurusGenerator\";\r\nimport PrerequisitesBuilder from \"./src/documentation/plugins/builders/Prerequisites/PrerequisitesBuilder\";\r\nimport UsageBuilder from \"./src/documentation/plugins/builders/Usage/UsageBuilder\";\r\n\r\nexport default {\r\n    projects : [{\r\n        project_file: \"package.json\",\r\n        config_file: \"code-narrator.config.ts\", //if you have specific app config file, e.g. for code-narrator, \"code-narrator.config.ts\" is the app config file\r\n        entry_file: \"./src/App.ts\",\r\n        cli_file:\"./src/cli.ts\",\r\n        project_path: \"./\",\r\n        source_path: \"./src\",\r\n        documentation_path: \"./docs\",\r\n        test_path: \"./test\",\r\n        exclude : ['ReadMe.md', '/node_modules', '/docs', '/test', '/__test__/**', '.env', '/.idea', '/.git',\r\n            '.gitignore', '/.code-narrator', '/classic', '/build', 'package-lock.json'],\r\n        readmeRoot : true\r\n    }],\r\n    //Order of plugins matter, ConfigurationGenerator runs first to get overview of the project.\r\n    builderPlugins : [\r\n        ConfigurationBuilder, PrerequisitesBuilder, UsageBuilder, FilesBuilder, FoldersBuilder, ReadMeBuilder, BehaviourBuilder\r\n    ],\r\n    generatorPlugin : [\r\n        DocusaurusGenerator\r\n    ],\r\n    gptSystemCommands : [\r\n        'If there is :::note, :::info, :::caution, :::tip, :::danger in the text, extract that from its location and format it correctly',\r\n        `Return your answer in {DocumentationType} format`,\r\n        `If you notice any secret information, replace it with ***** in your response`\r\n    ],\r\n    documentation_type: 'md', //What format should be generated, e.g. md, sphinx\r\n    document_file_extension: \".md\",\r\n    cache_file : '.code-narrator/cache.json' //location of the cache file. :::warning '.code-narrator/cache.json' should be committed into git.\r\n};\r\n",
		"documentation": "These are the app-specific config files called `code-narrator.config.ts`. When you use it in your project, you need to set these configurations correctly to match your project. Here's a detailed description of the configuration file and its purpose in the application:\n\n```markdown\n- **projects**: An array of project configurations, each containing:\n  - **project_file**: The main project file, usually `package.json`.\n  - **config_file**: The app-specific config file, e.g., `code-narrator.config.ts`.\n  - **entry_file**: The entry point of the application, e.g., `./src/App.ts`.\n  - **cli_file**: The command-line interface file, e.g., `./src/cli.ts`.\n  - **project_path**: The root path of the project, e.g., `./`.\n  - **source_path**: The source code path, e.g., `./src`.\n  - **documentation_path**: The path for generated documentation, e.g., `./docs`.\n  - **test_path**: The path for test files, e.g., `./test`.\n  - **exclude**: An array of files and folders to exclude from documentation.\n  - **readmeRoot**: A boolean indicating if the README file should be at the root of the project.\n\n- **builderPlugins**: An array of builder plugins, defining the order in which they run.\n\n- **generatorPlugin**: An array of generator plugins, such as `DocusaurusGenerator`.\n\n- **gptSystemCommands**: An array of GPT system commands for text formatting and information extraction.\n\n- **documentation_type**: The format of the generated documentation, e.g., `md`.\n\n- **document_file_extension**: The file extension for the generated documentation, e.g., `.md`.\n\n- **cache_file**: The location of the cache file. :::warning '.code-narrator/cache.json' should be committed into git.\n```\n\nTo retrieve a value from the config file, you can import the configuration and access the desired property. For example:\n\n```javascript\nimport config from \"./code-narrator.config.ts\";\n\nconsole.log(config.documentation_type); // Output: 'md'\n```\n\n:::note\nRemember to commit the cache file `.code-narrator/cache.json` into git.\n:::",
		"isFolder": false,
		"updated": "2023-03-28T14:07:57.016Z",
		"sidebar_position": 0,
		"sidebar_label": "Code-narrator.config.ts",
		"init": false,
		"postInit": false,
		"generator": "Configuration",
		"saveToPath": "./Configuration/",
		"documentation_type": "md",
		"question": "These are the app-specific config files called code-narrator.config.ts.\r\nWhen you use  in your project, you need set these configurations correctly to match your project.\r\nGive me a detailed description of them, and what their purpose is in the application if you can decide.\r\nGive example on how to retrieve from the config file\r\n###\r\n// code-narrator.config.ts\r\nimport ConfigurationBuilder from \"./src/documentation/plugins/builders/Configuration/ConfigurationBuilder\";\r\nimport FilesBuilder from \"./src/documentation/plugins/builders/Files/FilesBuilder\";\r\nimport FoldersBuilder from \"./src/documentation/plugins/builders/Folders/FoldersBuilder\";\r\nimport ReadMeBuilder from \"./src/documentation/plugins/builders/ReadMe/ReadMeBuilder\";\r\nimport BehaviourBuilder from \"./src/documentation/plugins/builders/Behaviour/BehaviourBuilder\";\r\nimport DocusaurusGenerator from \"./src/documentation/plugins/generators/Docusaurus/DocusaurusGenerator\";\r\nimport PrerequisitesBuilder from \"./src/documentation/plugins/builders/Prerequisites/PrerequisitesBuilder\";\r\nimport UsageBuilder from \"./src/documentation/plugins/builders/Usage/UsageBuilder\";\r\n\r\nexport default {\r\n    projects : [{\r\n        project_file: \"package.json\",\r\n        config_file: \"code-narrator.config.ts\", //if you have specific app config file, e.g. for code-narrator, \"code-narrator.config.ts\" is the app config file\r\n        entry_file: \"./src/App.ts\",\r\n        cli_file:\"./src/cli.ts\",\r\n        project_path: \"./\",\r\n        source_path: \"./src\",\r\n        documentation_path: \"./docs\",\r\n        test_path: \"./test\",\r\n        exclude : ['ReadMe.md', '/node_modules', '/docs', '/test', '/__test__/**', '.env', '/.idea', '/.git',\r\n            '.gitignore', '/.code-narrator', '/classic', '/build', 'package-lock.json'],\r\n        readmeRoot : true\r\n    }],\r\n    //Order of plugins matter, ConfigurationGenerator runs first to get overview of the project.\r\n    builderPlugins : [\r\n        ConfigurationBuilder, PrerequisitesBuilder, UsageBuilder, FilesBuilder, FoldersBuilder, ReadMeBuilder, BehaviourBuilder\r\n    ],\r\n    generatorPlugin : [\r\n        DocusaurusGenerator\r\n    ],\r\n    gptSystemCommands : [\r\n        'If there is :::note, :::info, :::caution, :::tip, :::danger in the text, extract that from its location and format it correctly',\r\n        `Return your answer in {DocumentationType} format`,\r\n        `If you notice any secret information, replace it with ***** in your response`\r\n    ],\r\n    documentation_type: 'md', //What format should be generated, e.g. md, sphinx\r\n    document_file_extension: \".md\",\r\n    cache_file : '.code-narrator/cache.json' //location of the cache file. :::warning '.code-narrator/cache.json' should be committed into git.\r\n};\r\n\r\n###",
		"id": "code-narrator.config.ts"
	},
	{
		"name": "jest.config.js",
		"path": "jest.config.js",
		"folderPath": "",
		"fileContent": "/** @type {import('ts-jest').JestConfigWithTsJest} */\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n};\n",
		"documentation": "# jest.config.js\n\n## Overview\n\nThe `jest.config.js` file is a configuration file for the Jest testing framework. It is used to customize the behavior of Jest when running tests in a project. This file is written in JavaScript and exports a configuration object that Jest uses to set up the testing environment and run tests.\n\nIn this specific file, we are using the `ts-jest` preset and setting the test environment to `node`. This means that the tests will be run using the TypeScript compiler and in a Node.js environment.\n\n## Configuration Object\n\nThe configuration object in this file has the following properties:\n\n### `preset`\n\n```javascript\npreset: 'ts-jest'\n```\n\nThe `preset` property is used to specify a predefined configuration for Jest. In this case, we are using the `ts-jest` preset, which is a TypeScript preprocessor for Jest. This allows us to use TypeScript in our test files and have Jest compile and run them correctly.\n\n### `testEnvironment`\n\n```javascript\ntestEnvironment: 'node'\n```\n\nThe `testEnvironment` property is used to specify the environment in which the tests will be run. In this case, we are using the `node` environment, which means that the tests will be run in a Node.js environment.\n\n## Usage\n\nTo use this configuration file in your project, you need to have Jest and `ts-jest` installed as dependencies. You can install them using the following commands:\n\n```bash\nnpm install --save-dev jest ts-jest\n```\n\nor\n\n```bash\nyarn add --dev jest ts-jest\n```\n\nOnce you have the dependencies installed, you can create a `jest.config.js` file in your project root with the provided content:\n\n```javascript\n/** @type {import('ts-jest').JestConfigWithTsJest} */\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n};\n```\n\nNow you can run your tests using the Jest command:\n\n```bash\nnpx jest\n```\n\nor\n\n```bash\nyarn jest\n```\n\nJest will automatically pick up the configuration from the `jest.config.js` file and run your tests accordingly.\n\n## Additional Resources\n\n- [Jest Configuration Documentation](https://jestjs.io/docs/configuration)\n- [ts-jest Documentation](https://kulshekhar.github.io/ts-jest/)\n- [Jest Test Environment Documentation](https://jestjs.io/docs/configuration#testenvironment-string)",
		"isFolder": false,
		"updated": "2023-03-27T19:00:44.544Z",
		"sidebar_position": 1,
		"sidebar_label": "jest.config.js",
		"init": false,
		"postInit": false,
		"generator": "Configuration",
		"saveToPath": "Configuration",
		"documentation_type": "md",
		"id": "jest.config.js"
	},
	{
		"name": "package.json",
		"path": "package.json",
		"folderPath": "./",
		"fileContent": "{\n  \"name\": \"code-narrator\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Uses OpenAI to generate documentation on code and tests. It is self documenting tool and should be validation of the documentation working, similar to a compiler compiling it self. Use code-narrator.config.ts file to set the configuration for your project, such as project path, doc, documentation type and more. The package can be install using 'npm i code-narrator -D'\",\n  \"keywords\": [\n    \"documentation\",\n    \"openai\",\n    \"autodoc\"\n  ],\n  \"homepage\": \"https://github.com/ingig/code-narrator\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ingig/code-narrator/issues\"\n  },\n  \"engines\": {\n    \"node\": \">18\"\n  },\n  \"repository\": {\n    \"url\": \"https://github.com/ingig/code-narrator\"\n  },\n  \"bin\": {\n    \"code-narrator-cli\": \"npx ts-node .\\\\src\\\\cli.ts\"\n  },\n  \"readme\": \"./docs/ReadMe.md\",\n  \"scripts\": {\n    \"start\": \"npx ts-node .\\\\src\\\\App.ts\"\n  },\n  \"author\": \"Ingi Gauti Ragnarsson @ingig\",\n  \"license\": \"ISC\",\n  \"main\": \"./src/App.ts\",\n  \"dependencies\": {\n    \"asynckit\": \"^0.4.0\",\n    \"axios\": \"^0.26.1\",\n    \"combined-stream\": \"^1.0.8\",\n    \"delayed-stream\": \"^1.0.0\",\n    \"dotenv\": \"^16.0.3\",\n    \"extract-json-from-string\": \"^1.0.1\",\n    \"follow-redirects\": \"^1.15.2\",\n    \"form-data\": \"^4.0.0\",\n    \"ignore\": \"^5.2.4\",\n    \"liquidjs\": \"^10.7.0\",\n    \"mime-db\": \"^1.52.0\",\n    \"mime-types\": \"^2.1.35\",\n    \"openai\": \"^3.1.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/preset-typescript\": \"^7.21.0\",\n    \"@jest/globals\": \"^29.5.0\",\n    \"@types/jest\": \"^29.4.0\",\n    \"@types/node\": \"^18.11.19\",\n    \"jest\": \"^29.4.2\",\n    \"ts-jest\": \"^29.0.5\",\n    \"ts-node\": \"^10.9.1\",\n    \"typescript\": \"^4.9.5\"\n  }\n}\n",
		"documentation": "This is a configuration file for the `code-narrator` package, a self-documenting tool that uses OpenAI to generate documentation on code and tests. It is intended for developers working with the package.\n\n:::info\n**Package Information:**\n- Name: code-narrator\n- Version: 1.0.1\n- Description: Uses OpenAI to generate documentation on code and tests. Configure your project using the `code-narrator.config.ts` file, setting project path, doc, documentation type, and more. Install the package using `npm i code-narrator -D`.\n- Keywords: documentation, openai, autodoc\n- Homepage: [https://github.com/ingig/code-narrator](https://github.com/ingig/code-narrator)\n- Bugs: [https://github.com/ingig/code-narrator/issues](https://github.com/ingig/code-narrator/issues)\n- Engines: Node >18\n- Repository: [https://github.com/ingig/code-narrator](https://github.com/ingig/code-narrator)\n:::\n\n:::note\n**Scripts:**\n- Start: `npx ts-node .\\src\\App.ts`\n:::\n\n:::tip\n**Author:** Ingi Gauti Ragnarsson @ingig\n**License:** ISC\n**Main:** ./src/App.ts\n:::\n\n:::caution\n**Dependencies:**\n- asynckit: ^0.4.0\n- axios: ^0.26.1\n- combined-stream: ^1.0.8\n- delayed-stream: ^1.0.0\n- dotenv: ^16.0.3\n- extract-json-from-string: ^1.0.1\n- follow-redirects: ^1.15.2\n- form-data: ^4.0.0\n- ignore: ^5.2.4\n- liquidjs: ^10.7.0\n- mime-db: ^1.52.0\n- mime-types: ^2.1.35\n- openai: ^3.1.0\n:::\n\n:::danger\n**Dev Dependencies:**\n- @babel/preset-typescript: ^7.21.0\n- @jest/globals: ^29.5.0\n- @types/jest: ^29.4.0\n- @types/node: ^18.11.19\n- jest: ^29.4.2\n- ts-jest: ^29.0.5\n- ts-node: ^10.9.1\n- typescript: ^4.9.5\n:::",
		"isFolder": false,
		"updated": "2023-03-28T14:44:08.220Z",
		"sidebar_position": 1,
		"sidebar_label": "Package.json",
		"init": false,
		"postInit": false,
		"generator": "Configuration",
		"saveToPath": "./Configuration/",
		"documentation_type": "md",
		"question": "This is a configuration file that is meant for developers of .\r\nIf you are using  as a package in your project this file is irrelevant.\r\nAct as a documentation expert. Write detailed description of this configuration file\r\n###\r\n{\n  \"name\": \"code-narrator\",\n  \"version\": \"1.0.1\",\n  \"description\": \"Uses OpenAI to generate documentation on code and tests. It is self documenting tool and should be validation of the documentation working, similar to a compiler compiling it self. Use code-narrator.config.ts file to set the configuration for your project, such as project path, doc, documentation type and more. The package can be install using 'npm i code-narrator -D'\",\n  \"keywords\": [\n    \"documentation\",\n    \"openai\",\n    \"autodoc\"\n  ],\n  \"homepage\": \"https://github.com/ingig/code-narrator\",\n  \"bugs\": {\n    \"url\": \"https://github.com/ingig/code-narrator/issues\"\n  },\n  \"engines\": {\n    \"node\": \">18\"\n  },\n  \"repository\": {\n    \"url\": \"https://github.com/ingig/code-narrator\"\n  },\n  \"bin\": {\n    \"code-narrator-cli\": \"npx ts-node .\\\\src\\\\cli.ts\"\n  },\n  \"readme\": \"./docs/ReadMe.md\",\n  \"scripts\": {\n    \"start\": \"npx ts-node .\\\\src\\\\App.ts\"\n  },\n  \"author\": \"Ingi Gauti Ragnarsson @ingig\",\n  \"license\": \"ISC\",\n  \"main\": \"./src/App.ts\",\n  \"dependencies\": {\n    \"asynckit\": \"^0.4.0\",\n    \"axios\": \"^0.26.1\",\n    \"combined-stream\": \"^1.0.8\",\n    \"delayed-stream\": \"^1.0.0\",\n    \"dotenv\": \"^16.0.3\",\n    \"extract-json-from-string\": \"^1.0.1\",\n    \"follow-redirects\": \"^1.15.2\",\n    \"form-data\": \"^4.0.0\",\n    \"ignore\": \"^5.2.4\",\n    \"liquidjs\": \"^10.7.0\",\n    \"mime-db\": \"^1.52.0\",\n    \"mime-types\": \"^2.1.35\",\n    \"openai\": \"^3.1.0\"\n  },\n  \"devDependencies\": {\n    \"@babel/preset-typescript\": \"^7.21.0\",\n    \"@jest/globals\": \"^29.5.0\",\n    \"@types/jest\": \"^29.4.0\",\n    \"@types/node\": \"^18.11.19\",\n    \"jest\": \"^29.4.2\",\n    \"ts-jest\": \"^29.0.5\",\n    \"ts-node\": \"^10.9.1\",\n    \"typescript\": \"^4.9.5\"\n  }\n}\n\r\n###",
		"id": "package.json"
	},
	{
		"name": "tsconfig.json",
		"path": "tsconfig.json",
		"folderPath": "",
		"fileContent": "{\r\n  \"compilerOptions\": {\r\n    \"module\": \"CommonJS\",\r\n    \"target\": \"ES2021\",\r\n    \"moduleResolution\": \"Node\",\r\n    \"esModuleInterop\": true,\r\n    \"sourceMap\": true,\r\n    \"outDir\": \"build\",\r\n    \"baseUrl\": \"./\",\r\n    \"emitDecoratorMetadata\": true,\r\n    \"experimentalDecorators\": true,\r\n    \"strict\": true,\r\n    \"resolveJsonModule\": true,\r\n    \"isolatedModules\": true,\r\n    \"typeRoots\": [\"node_modules/@types\", \"types\"],\r\n    \"paths\": {\r\n      \"*\" : [\"@types/*\"]\r\n    }\r\n  },\r\n  \"exclude\": [\r\n    \"node_modules\"\r\n  ],\r\n  \"files\": [\r\n    \"./src/index.ts\"\r\n  ],\r\n  \"compileOnSave\": true\r\n}",
		"documentation": "# tsconfig.json\n\nThe `tsconfig.json` file is a configuration file for TypeScript projects. It specifies the root files and the compiler options required to compile the project. This file is used by the TypeScript compiler (`tsc`) to guide the compilation process and generate the desired JavaScript output.\n\n## Compiler Options\n\nThe `compilerOptions` object contains various properties that configure the TypeScript compiler. Here's a description of each property in the given file:\n\n### module\n\n```json\n\"module\": \"CommonJS\"\n```\n\nThe `module` property specifies the module system to be used. In this case, it is set to `CommonJS`, which is the default module system for Node.js.\n\n### target\n\n```json\n\"target\": \"ES2021\"\n```\n\nThe `target` property sets the ECMAScript target version for the compiled JavaScript output. In this case, it is set to `ES2021`.\n\n### moduleResolution\n\n```json\n\"moduleResolution\": \"Node\"\n```\n\nThe `moduleResolution` property determines the strategy used for resolving module imports. In this case, it is set to `Node`, which follows the Node.js module resolution algorithm.\n\n### esModuleInterop\n\n```json\n\"esModuleInterop\": true\n```\n\nThe `esModuleInterop` property enables compatibility between CommonJS and ES modules. When set to `true`, it allows using default imports with CommonJS modules.\n\n### sourceMap\n\n```json\n\"sourceMap\": true\n```\n\nThe `sourceMap` property, when set to `true`, generates source map files alongside the compiled JavaScript files. These files help in debugging the TypeScript code.\n\n### outDir\n\n```json\n\"outDir\": \"build\"\n```\n\nThe `outDir` property specifies the output directory for the compiled JavaScript files. In this case, it is set to the `build` folder.\n\n### baseUrl\n\n```json\n\"baseUrl\": \"./\"\n```\n\nThe `baseUrl` property sets the base URL for resolving non-relative module imports. In this case, it is set to the current directory.\n\n### emitDecoratorMetadata\n\n```json\n\"emitDecoratorMetadata\": true\n```\n\nThe `emitDecoratorMetadata` property, when set to `true`, emits metadata for decorators in the compiled JavaScript output.\n\n### experimentalDecorators\n\n```json\n\"experimentalDecorators\": true\n```\n\nThe `experimentalDecorators` property enables support for experimental decorators, a proposed extension to the ECMAScript standard.\n\n### strict\n\n```json\n\"strict\": true\n```\n\nThe `strict` property enables all strict type-checking options in the TypeScript compiler.\n\n### resolveJsonModule\n\n```json\n\"resolveJsonModule\": true\n```\n\nThe `resolveJsonModule` property allows importing JSON files as modules.\n\n### isolatedModules\n\n```json\n\"isolatedModules\": true\n```\n\nThe `isolatedModules` property ensures that each file is treated as a separate module, preventing global scope pollution.\n\n### typeRoots\n\n```json\n\"typeRoots\": [\"node_modules/@types\", \"types\"]\n```\n\nThe `typeRoots` property specifies the folders containing type declaration files.\n\n### paths\n\n```json\n\"paths\": {\n  \"*\": [\"@types/*\"]\n}\n```\n\nThe `paths` property maps module import paths to their corresponding locations.\n\n## Exclude\n\n```json\n\"exclude\": [\n  \"node_modules\"\n]\n```\n\nThe `exclude` property lists the folders or files that should be excluded from the compilation process. In this case, the `node_modules` folder is excluded.\n\n## Files\n\n```json\n\"files\": [\n  \"./src/index.ts\"\n]\n```\n\nThe `files` property lists the root files to be included in the compilation process. In this case, the `./src/index.ts` file is included.\n\n## compileOnSave\n\n```json\n\"compileOnSave\": true\n```\n\nThe `compileOnSave` property, when set to `true`, triggers the TypeScript compiler to compile the project whenever a file is saved.",
		"isFolder": false,
		"updated": "2023-03-27T19:03:18.563Z",
		"sidebar_position": 3,
		"sidebar_label": "tsconfig.json",
		"init": false,
		"postInit": false,
		"generator": "Configuration",
		"saveToPath": "Configuration",
		"documentation_type": "md",
		"id": "tsconfig.json"
	},
	{
		"name": "App.ts",
		"path": "src\\App.ts",
		"folderPath": "src",
		"fileContent": "import ConfigHelper from \"./utils/ConfigHelper\";\r\nimport DocumentationBuilder from \"./documentation/DocumentationBuilder\";\r\nimport DocumentationCache from \"./documentation/DocumentationCache\";\r\nimport DocumentationGenerator from \"./documentation/DocumentationGenerator\";\r\nimport config from '../code-narrator.config';\r\n\r\n/*\r\nAbout code-narrator\r\nThis application is installed with \"npm i code-narrator\", and executed either by npm run start or by using cli.\r\nWhen starting it will load up the configuration and cached documentation.\r\nThen it will go through the project code, reading the file & folder structure\r\nif the file or folder does not exist in the cache or the file has changed since last cached\r\ncode-narrator will send the code to GPT and ask for documentation in an .md format.\r\nWhen it receives the documentation, it writes it to the cache.\r\nWhen all files and folders have been parsed, then code-narrator creates the documentation from the cache\r\n\r\nThere are few rules to follow\r\n- Write description about the project in the project file (e.g. package.json)\r\n- If GPT generates wrong documentation, the code is probably not clear for humans either. Try adjusting code or adding one line comment to make code clearer\r\n- You can use :::tip or :::danger in you comments in your code files.\r\n */\r\nexport default class App {\r\n    static repositoryUrl = ''\r\n    static Project : any;\r\n    static StartFile= '';\r\n    public async run() {\r\n        let projects = config.projects;\r\n\r\n        for (let i=0;i<projects.length;i++) {\r\n            App.Project = projects[i];\r\n\r\n            await ConfigHelper.load(config, projects[i]);\r\n            DocumentationCache.load();\r\n\r\n            let builder = new DocumentationBuilder();\r\n            await builder.build(projects[i]);\r\n        }\r\n\r\n        let generator = new DocumentationGenerator();\r\n        generator.make();\r\n\r\n        console.log('Done generating documents')\r\n\r\n    }\r\n}\r\n\r\nlet app = new App();\r\napp.run();",
		"documentation": "# App.ts\n\nThis file contains the main class `App` and its implementation for the code-narrator application. The code-narrator application is used to generate documentation for a project by analyzing its code and folder structure, and then using GPT to generate documentation in markdown format.\n\n## Table of Contents\n\n- [Class: App](#class-app)\n  - [Static Properties](#static-properties)\n  - [Method: run](#method-run)\n- [Usage](#usage)\n\n## Class: App\n\nThe `App` class is the main class responsible for running the code-narrator application. It contains the main logic for loading configurations, caching documentation, building documentation, and generating the final documentation.\n\n### Static Properties\n\n- `repositoryUrl`: A static property that holds the repository URL for the project.\n- `Project`: A static property that holds the current project being processed.\n- `StartFile`: A static property that holds the starting file for the documentation generation process.\n\n### Method: run\n\nThe `run` method is an asynchronous method that performs the main logic for the code-narrator application. It iterates through the projects defined in the configuration, loads the configuration and documentation cache, builds the documentation, and generates the final documentation.\n\n#### Parameters\n\nNone.\n\n#### Example\n\n```javascript\nlet app = new App();\napp.run();\n```\n\n## Usage\n\nTo use the `App` class, simply create a new instance of the class and call the `run` method. This will start the documentation generation process for the projects defined in the configuration.\n\n```javascript\nlet app = new App();\napp.run();\n```\n\n:::note\nRemember to follow the rules mentioned in the file content, such as writing a description about the project in the project file (e.g., package.json), and using :::tip or :::danger in your comments in your code files.\n:::",
		"isFolder": false,
		"updated": "2023-03-28T11:11:50.312Z",
		"sidebar_position": 0,
		"sidebar_label": "App.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src",
		"documentation_type": "md",
		"id": "src\\App.ts"
	},
	{
		"name": "cli.ts",
		"path": "src\\cli.ts",
		"folderPath": "src",
		"fileContent": "#!/usr/bin/env node\r\n\r\nimport App from \"./App\";\r\n\r\nlet app = new App();\r\napp.run();",
		"documentation": "# cli.ts\n\n## Overview\n\nThe `cli.ts` file is an entry point for a command-line interface (CLI) application built using the `App` class. This file initializes the `App` class and runs the application.\n\n## Usage\n\nTo use the `cli.ts` file, you can run it directly from the command line using the following command:\n\n```bash\n$ ./cli.ts\n```\n\nAlternatively, you can use Node.js to execute the file:\n\n```bash\n$ node cli.ts\n```\n\n## App Class\n\nThe `App` class is imported from the `App.ts` file and is responsible for managing the application's functionality. The `App` class should contain methods and properties that define the behavior of the CLI application.\n\n### Initialization\n\nThe `App` class is initialized using the following code:\n\n```typescript\nlet app = new App();\n```\n\nThis creates a new instance of the `App` class and assigns it to the `app` variable.\n\n### Running the Application\n\nTo run the application, call the `run` method on the `app` instance:\n\n```typescript\napp.run();\n```\n\nThis method should contain the main logic of the CLI application, such as parsing command-line arguments, executing commands, and displaying output.\n\n## Methods\n\n### run()\n\nThe `run` method is responsible for executing the main logic of the CLI application. This method should be implemented in the `App` class to handle command-line arguments, execute commands, and display output.\n\n## Technical Concepts\n\n### Shebang\n\nThe first line of the `cli.ts` file is a shebang:\n\n```bash\n#!/usr/bin/env node\n```\n\nThis line tells the operating system to use the Node.js interpreter to execute the script. This allows the script to be run directly from the command line, as mentioned in the Usage section.\n\n## Conclusion\n\nThe `cli.ts` file serves as the entry point for a CLI application built using the `App` class. It initializes the `App` class, runs the application, and handles command-line arguments and output.",
		"isFolder": false,
		"updated": "2023-03-27T19:04:54.505Z",
		"sidebar_position": 1,
		"sidebar_label": "cli.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src",
		"documentation_type": "md",
		"id": "src\\cli.ts"
	},
	{
		"name": "Document.ts",
		"path": "src\\documentation\\Document.ts",
		"folderPath": "src\\documentation",
		"fileContent": "import fs from \"fs\";\r\nimport Helper from \"../utils/Helper\";\r\nimport ConfigHelper from \"../utils/ConfigHelper\";\r\nimport * as path from 'path';\r\n\r\nexport default class Document {\r\n\r\n    id : string;\r\n    name = '';\r\n    path = '';\r\n    folderPath = '';\r\n    fileContent = '';\r\n    documentation = '';\r\n    isFolder = false;\r\n    updated : Date = new Date();\r\n    sidebar_position? : number = undefined;\r\n    sidebar_label? : string = undefined;\r\n    init = false;\r\n    postInit = false;\r\n    generator: string = '';\r\n    saveToPath = '';\r\n    data : any;\r\n    documentation_type = 'md'\r\n    question = '';\r\n\r\n    constructor(name: string, filePath: string, folderPath : string, updated : Date, sidebar_position? : number, sidebar_label? : string) {\r\n        this.name = name;\r\n        let project_path = ConfigHelper.get('project_path')\r\n        this.path = path.relative(project_path, filePath);\r\n        this.saveToPath = this.path;\r\n        this.id = (this.path) ? Document.getId(this.path) : Document.getId(name);\r\n        this.folderPath = folderPath;\r\n        this.isFolder = (filePath == folderPath);\r\n        this.updated = updated;\r\n        this.sidebar_position = sidebar_position;\r\n        this.sidebar_label = sidebar_label ?? Helper.upperFirstLetter(name);\r\n        if (!this.isFolder) {\r\n            this.fileContent = fs.readFileSync(filePath).toString();\r\n        }\r\n    }\r\n\r\n    public static getId(path: string) {\r\n        return path;\r\n    }\r\n\r\n\r\n}",
		"documentation": "# Document.ts\n\nThis file defines a `Document` class that represents a document or folder in a project. The class contains properties and methods to manage the document's metadata, content, and related information.\n\n## Table of Contents\n\n- [Class Definition](#class-definition)\n- [Constructor](#constructor)\n- [Methods](#methods)\n  - [getId](#getid)\n\n## Class Definition\n\nThe `Document` class has the following properties:\n\n- `id`: A unique identifier for the document.\n- `name`: The name of the document.\n- `path`: The relative path of the document in the project.\n- `folderPath`: The path of the folder containing the document.\n- `fileContent`: The content of the document file.\n- `documentation`: The documentation associated with the document.\n- `isFolder`: A boolean indicating if the document represents a folder.\n- `updated`: A `Date` object representing the last update time of the document.\n- `sidebar_position`: An optional number representing the position of the document in the sidebar.\n- `sidebar_label`: An optional string representing the label of the document in the sidebar.\n- `init`: A boolean indicating if the document has been initialized.\n- `postInit`: A boolean indicating if the document has been post-initialized.\n- `generator`: A string representing the generator used to create the document.\n- `saveToPath`: The path where the document should be saved.\n- `data`: Any additional data associated with the document.\n- `documentation_type`: A string representing the type of documentation (default is 'md').\n- `question`: A string representing a question related to the document.\n\n## Constructor\n\nThe constructor for the `Document` class takes the following parameters:\n\n- `name`: The name of the document.\n- `filePath`: The path of the document file.\n- `folderPath`: The path of the folder containing the document.\n- `updated`: A `Date` object representing the last update time of the document.\n- `sidebar_position?`: An optional number representing the position of the document in the sidebar.\n- `sidebar_label?`: An optional string representing the label of the document in the sidebar.\n\nThe constructor initializes the properties of the `Document` class and reads the file content if the document is not a folder.\n\n## Methods\n\n### getId\n\n```typescript\npublic static getId(path: string): string\n```\n\nThe `getId` method is a static method that takes a `path` parameter and returns a unique identifier for the document based on the path. This method is used to generate the `id` property of the `Document` class.",
		"isFolder": false,
		"updated": "2023-03-28T13:05:42.665Z",
		"sidebar_position": 0,
		"sidebar_label": "Document.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"Document.ts\"\r\n\r\n###\r\nIf this is a code file, then\n- Write detailed description for the code that will follow. \n- Give multiple examples of how to use this class before listing each method\n- Create a description for each method in the code. \n- List out the parameters in methods (only if there are any) and write a description for each parameter.\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\n- Divide the document into sections with clear headings and subheadings.\nElse \n- Write detailed description about the file content will follow.\n                    \r\n###\r\n\r\nThis is the content of the file:\r\n###\r\nimport fs from \"fs\";\r\nimport Helper from \"../utils/Helper\";\r\nimport ConfigHelper from \"../utils/ConfigHelper\";\r\nimport * as path from 'path';\r\n\r\nexport default class Document {\r\n\r\n    id : string;\r\n    name = '';\r\n    path = '';\r\n    folderPath = '';\r\n    fileContent = '';\r\n    documentation = '';\r\n    isFolder = false;\r\n    updated : Date = new Date();\r\n    sidebar_position? : number = undefined;\r\n    sidebar_label? : string = undefined;\r\n    init = false;\r\n    postInit = false;\r\n    generator: string = '';\r\n    saveToPath = '';\r\n    data : any;\r\n    documentation_type = 'md'\r\n    question = '';\r\n\r\n    constructor(name: string, filePath: string, folderPath : string, updated : Date, sidebar_position? : number, sidebar_label? : string) {\r\n        this.name = name;\r\n        let project_path = ConfigHelper.get('project_path')\r\n        this.path = path.relative(project_path, filePath);\r\n        this.saveToPath = this.path;\r\n        this.id = (this.path) ? Document.getId(this.path) : Document.getId(name);\r\n        this.folderPath = folderPath;\r\n        this.isFolder = (filePath == folderPath);\r\n        this.updated = updated;\r\n        this.sidebar_position = sidebar_position;\r\n        this.sidebar_label = sidebar_label ?? Helper.upperFirstLetter(name);\r\n        if (!this.isFolder) {\r\n            this.fileContent = fs.readFileSync(filePath).toString();\r\n        }\r\n    }\r\n\r\n    public static getId(path: string) {\r\n        return path;\r\n    }\r\n\r\n\r\n}\r\n###\r\n",
		"id": "src\\documentation\\Document.ts"
	},
	{
		"name": "DocumentationBuilder.ts",
		"path": "src\\documentation\\DocumentationBuilder.ts",
		"folderPath": "src\\documentation",
		"fileContent": "import OpenAIRepository from \"../repositories/OpenAIRepository\";\r\nimport ConfigHelper from \"../utils/ConfigHelper\";\r\nimport BaseBuilder from \"./plugins/builders/BaseBuilder\";\r\n\r\nexport default class DocumentationBuilder {\r\n    openAIRepository: OpenAIRepository;\r\n    projectPath : string;\r\n    constructor() {\r\n        this.openAIRepository = new OpenAIRepository();\r\n        this.projectPath = ConfigHelper.get('project_path');\r\n    }\r\n\r\n    public async build(project : any) {\r\n        let plugins = ConfigHelper.BuilderPlugins;\r\n        for (let i=0;i<plugins.length;i++) {\r\n            let generator = new plugins[i](project) as BaseBuilder;\r\n            await generator.generate();\r\n        }\r\n    }\r\n\r\n}",
		"documentation": "# DocumentationBuilder.ts\n\n## Overview\n\nThe `DocumentationBuilder.ts` file is a TypeScript module that provides a class called `DocumentationBuilder`. This class is responsible for generating documentation for a given project using a set of plugins. The class interacts with the OpenAIRepository and utilizes the ConfigHelper utility to manage configurations.\n\n## Usage\n\nTo use the `DocumentationBuilder` class, you need to import it and create a new instance. Then, you can call the `build` method with a project object to generate the documentation.\n\n```typescript\nimport DocumentationBuilder from './DocumentationBuilder';\n\nconst docBuilder = new DocumentationBuilder();\ndocBuilder.build(project);\n```\n\n## Class: DocumentationBuilder\n\n### Properties\n\n- `openAIRepository: OpenAIRepository`: An instance of the `OpenAIRepository` class, which is used to interact with the OpenAI API.\n- `projectPath: string`: A string representing the path to the project for which the documentation is being generated. This value is retrieved from the configuration file using the `ConfigHelper` utility.\n\n### Constructor\n\nThe constructor initializes the `openAIRepository` and `projectPath` properties.\n\n```typescript\nconstructor() {\n    this.openAIRepository = new OpenAIRepository();\n    this.projectPath = ConfigHelper.get('project_path');\n}\n```\n\n### Method: build(project: any)\n\nThis method generates the documentation for the given project using the configured plugins.\n\n- `project: any`: The project object for which the documentation is being generated.\n\n#### Example\n\n```typescript\nconst docBuilder = new DocumentationBuilder();\ndocBuilder.build(project);\n```\n\n## Technical Concepts\n\n### ConfigHelper\n\nThe `ConfigHelper` utility is used to manage configurations in the application. It provides methods to get and set configuration values.\n\n### OpenAIRepository\n\nThe `OpenAIRepository` class is responsible for interacting with the OpenAI API. It provides methods to fetch data from the API and process it.\n\n### BaseBuilder\n\nThe `BaseBuilder` class is an abstract class that serves as a base for all builder plugins. Each plugin should extend this class and implement the `generate` method to generate documentation for a specific part of the project.\n\n## Sections\n\n- Overview\n- Usage\n- Class: DocumentationBuilder\n  - Properties\n  - Constructor\n  - Method: build(project: any)\n- Technical Concepts\n  - ConfigHelper\n  - OpenAIRepository\n  - BaseBuilder",
		"isFolder": false,
		"updated": "2023-03-27T19:07:19.171Z",
		"sidebar_position": 1,
		"sidebar_label": "DocumentationBuilder.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation",
		"documentation_type": "md",
		"id": "src\\documentation\\DocumentationBuilder.ts"
	},
	{
		"name": "DocumentationCache.ts",
		"path": "src\\documentation\\DocumentationCache.ts",
		"folderPath": "src\\documentation",
		"fileContent": "import fs from \"fs\";\r\nimport ConfigHelper from \"../utils/ConfigHelper\";\r\nimport Document from \"../documentation/Document\";\r\nimport path from \"path\";\r\nimport App from \"../App\";\r\n\r\n/*\r\n:::danger Make sure to add the cache file (default is .codenarrator\\cache.json) to git, so you don't have to query GPT on each run.\r\n */\r\nexport default class DocumentationCache {\r\n\r\n    static Documents : Document[] | null = null;\r\n    static cacheFilePath = '';\r\n    private constructor() {\r\n        let project_path = ConfigHelper.get('project_path');\r\n        let cache_file = ConfigHelper.CacheFilePath;\r\n        DocumentationCache.cacheFilePath = path.join(project_path, cache_file);\r\n        if (fs.existsSync(DocumentationCache.cacheFilePath)) {\r\n            let str = fs.readFileSync(DocumentationCache.cacheFilePath).toString();\r\n            DocumentationCache.Documents = JSON.parse(str) as Document[];\r\n        } else {\r\n            DocumentationCache.Documents = [];\r\n        }\r\n    }\r\n\r\n    public static load() {\r\n        new DocumentationCache();\r\n    }\r\n    public static getIndex(id : string) : number {\r\n        for (let i=0; DocumentationCache.Documents && i<DocumentationCache.Documents.length; i++) {\r\n            if (DocumentationCache.Documents[i] && DocumentationCache.Documents[i].id == id) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    public static get(path: string) : Document | undefined {\r\n        let id = Document.getId(path);\r\n        let idx = this.getIndex(id);\r\n        if (!DocumentationCache.Documents || idx == -1) return;\r\n        return DocumentationCache.Documents[idx];\r\n    }\r\n    static remove(document : Document) {\r\n        let idx = DocumentationCache.getIndex(Document.getId(document.path))\r\n        if (idx != -1 && DocumentationCache.Documents) {\r\n            delete DocumentationCache.Documents[idx];\r\n        }\r\n        let docPath = App.Project.documentation_path;\r\n        let filePath = path.join(docPath, document.path);\r\n        if (fs.existsSync(filePath)) {\r\n            fs.rmSync(filePath)\r\n        }\r\n\r\n    }\r\n\r\n    static set(document: Document) {\r\n        let idx = this.getIndex(document.id);\r\n        if (idx == -1) {\r\n            DocumentationCache.Documents?.push(document);\r\n        } else {\r\n            DocumentationCache.Documents![idx] = document;\r\n        }\r\n        let content = JSON.stringify(DocumentationCache.Documents, null,'\\t');\r\n        fs.writeFileSync(this.cacheFilePath, content);\r\n    }\r\n\r\n    static getByFolderPath(path: string) {\r\n        let suggestions : Document[] = [];\r\n        for (let i=0; DocumentationCache.Documents && i<DocumentationCache.Documents.length; i++) {\r\n            if (DocumentationCache.Documents[i] && DocumentationCache.Documents[i].folderPath == path) {\r\n                suggestions.push(DocumentationCache.Documents[i])\r\n            }\r\n        }\r\n        return suggestions;\r\n    }\r\n}",
		"documentation": "# DocumentationCache.ts\n\n## Overview\n\nThe `DocumentationCache.ts` file is a TypeScript module that provides a class named `DocumentationCache`. This class is responsible for managing the cache of documentation files in a project. It provides methods to load, get, set, remove, and retrieve documentation files by their folder path.\n\n## Usage\n\nTo use the `DocumentationCache` class, you should first import it:\n\n```typescript\nimport DocumentationCache from \"./path/to/DocumentationCache\";\n```\n\nThen, you can call its static methods to interact with the cache.\n\n## Methods\n\n### load()\n\nThis static method initializes the `DocumentationCache` by loading the cache file from the project's configuration. If the cache file exists, it reads its content and parses it as an array of `Document` objects. If the cache file does not exist, it initializes an empty array.\n\n```typescript\nDocumentationCache.load();\n```\n\n### getIndex(id: string): number\n\nThis static method takes an `id` string as a parameter and returns the index of the `Document` with the given `id` in the cache. If the document is not found, it returns `-1`.\n\n```typescript\nconst index = DocumentationCache.getIndex(\"some-document-id\");\n```\n\n### get(path: string): Document | undefined\n\nThis static method takes a `path` string as a parameter and returns the `Document` object associated with the given path. If the document is not found, it returns `undefined`.\n\n```typescript\nconst document = DocumentationCache.get(\"path/to/document\");\n```\n\n### remove(document: Document)\n\nThis static method takes a `Document` object as a parameter and removes it from the cache. It also deletes the corresponding documentation file from the project's documentation folder.\n\n```typescript\nDocumentationCache.remove(document);\n```\n\n### set(document: Document)\n\nThis static method takes a `Document` object as a parameter and adds or updates it in the cache. It also writes the updated cache to the cache file.\n\n```typescript\nDocumentationCache.set(document);\n```\n\n### getByFolderPath(path: string)\n\nThis static method takes a `path` string as a parameter and returns an array of `Document` objects that are located in the specified folder path.\n\n```typescript\nconst documents = DocumentationCache.getByFolderPath(\"path/to/folder\");\n```\n\n## :::danger\nMake sure to add the cache file (default is `.codenarrator\\cache.json`) to git, so you don't have to query GPT on each run.\n:::",
		"isFolder": false,
		"updated": "2023-03-28T12:32:05.377Z",
		"sidebar_position": 2,
		"sidebar_label": "DocumentationCache.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation",
		"documentation_type": "md",
		"id": "src\\documentation\\DocumentationCache.ts"
	},
	{
		"name": "DocumentationGenerator.ts",
		"path": "src\\documentation\\DocumentationGenerator.ts",
		"folderPath": "src\\documentation",
		"fileContent": "import fs from \"fs\";\r\nimport ConfigHelper from \"../utils/ConfigHelper\";\r\nimport DocumentationCache from \"./DocumentationCache\";\r\nimport path from \"path\";\r\nimport config from \"../../code-narrator.config\";\r\nimport BaseGenerator from \"./plugins/generators/BaseGenerator\";\r\n\r\nexport default class DocumentationGenerator {\r\n\r\n    public make() {\r\n        let documents = DocumentationCache.Documents;\r\n        if (!documents) return;\r\n\r\n        let documentationPath = ConfigHelper.get('documentation_path');\r\n        let project_path = ConfigHelper.get('project_path');\r\n\r\n        for (let i=0;i<config.projects.length;i++) {\r\n            if (config.projects[i].readmeRoot) {\r\n                let document = DocumentationCache.get('ReadMe');\r\n                if (document) {\r\n                    fs.writeFileSync(path.join(config.projects[i].project_path, 'ReadMe.md'), document.documentation);\r\n                }\r\n            }\r\n        }\r\n\r\n        let plugins = config.generatorPlugin;\r\n        for (let i=0;i<documents.length;i++) {\r\n            if (!documents[i]) continue;\r\n\r\n            let folderPath = documents[i].folderPath.replace(project_path, '');\r\n            let document = documents[i]\r\n\r\n            if (folderPath == '.\\\\' || folderPath == './') folderPath = ''\r\n\r\n            let filePath = path.join(documentationPath, documents[i].saveToPath, documents[i].name + ConfigHelper.DocumentExtension);\r\n            fs.mkdirSync(path.join(documentationPath, documents[i].saveToPath), {recursive: true})\r\n\r\n            for (let i=0;i<plugins.length;i++) {\r\n                let tmp = new plugins[i]() as BaseGenerator;\r\n                tmp.process(document)\r\n            }\r\n\r\n            fs.writeFileSync(filePath, document.documentation);\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n}",
		"documentation": "# DocumentationGenerator.ts\n\nThis is a TypeScript code file that defines a class called `DocumentationGenerator`. The purpose of this class is to generate documentation files based on the contents of a cache and a configuration file. The generated documentation files are saved to a specified path.\n\n## Usage\n\nTo use the `DocumentationGenerator` class, you need to create an instance of the class and call the `make()` method.\n\n```typescript\nimport DocumentationGenerator from './DocumentationGenerator';\n\nconst generator = new DocumentationGenerator();\ngenerator.make();\n```\n\n## Class: DocumentationGenerator\n\n### Method: make()\n\nThis method generates documentation files based on the contents of the `DocumentationCache` and the configuration file `code-narrator.config`. It saves the generated documentation files to the specified path in the configuration file.\n\n#### Parameters\n\nNone.\n\n#### Example\n\n```typescript\nconst generator = new DocumentationGenerator();\ngenerator.make();\n```\n\n## Technical Concepts\n\n### ConfigHelper\n\n`ConfigHelper` is a utility class that helps in fetching configuration values from the `code-narrator.config` file.\n\n### DocumentationCache\n\n`DocumentationCache` is a class that stores the documentation data in a cache. It provides methods to get and set documentation data.\n\n### BaseGenerator\n\n`BaseGenerator` is a base class for generator plugins. Generator plugins are used to process the documentation data before saving it to a file.\n\n## File Structure\n\nThe file imports the following modules and classes:\n\n- `fs` from the `fs` module\n- `ConfigHelper` from `../utils/ConfigHelper`\n- `DocumentationCache` from `./DocumentationCache`\n- `path` from the `path` module\n- `config` from `../../code-narrator.config`\n- `BaseGenerator` from `./plugins/generators/BaseGenerator`\n\nThe `DocumentationGenerator` class has a single method called `make()`. This method iterates through the projects and documentation data, processes the data using generator plugins, and saves the generated documentation files to the specified path.",
		"isFolder": false,
		"updated": "2023-03-28T14:48:25.349Z",
		"sidebar_position": 3,
		"sidebar_label": "DocumentationGenerator.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"DocumentationGenerator.ts\"\r\nThe file name is: DocumentationGenerator.ts\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nimport fs from \"fs\";\r\nimport ConfigHelper from \"../utils/ConfigHelper\";\r\nimport DocumentationCache from \"./DocumentationCache\";\r\nimport path from \"path\";\r\nimport config from \"../../code-narrator.config\";\r\nimport BaseGenerator from \"./plugins/generators/BaseGenerator\";\r\n\r\nexport default class DocumentationGenerator {\r\n\r\n    public make() {\r\n        let documents = DocumentationCache.Documents;\r\n        if (!documents) return;\r\n\r\n        let documentationPath = ConfigHelper.get('documentation_path');\r\n        let project_path = ConfigHelper.get('project_path');\r\n\r\n        for (let i=0;i<config.projects.length;i++) {\r\n            if (config.projects[i].readmeRoot) {\r\n                let document = DocumentationCache.get('ReadMe');\r\n                if (document) {\r\n                    fs.writeFileSync(path.join(config.projects[i].project_path, 'ReadMe.md'), document.documentation);\r\n                }\r\n            }\r\n        }\r\n\r\n        let plugins = config.generatorPlugin;\r\n        for (let i=0;i<documents.length;i++) {\r\n            if (!documents[i]) continue;\r\n\r\n            let folderPath = documents[i].folderPath.replace(project_path, '');\r\n            let document = documents[i]\r\n\r\n            if (folderPath == '.\\\\' || folderPath == './') folderPath = ''\r\n\r\n            let filePath = path.join(documentationPath, documents[i].saveToPath, documents[i].name + ConfigHelper.DocumentExtension);\r\n            fs.mkdirSync(path.join(documentationPath, documents[i].saveToPath), {recursive: true})\r\n\r\n            for (let i=0;i<plugins.length;i++) {\r\n                let tmp = new plugins[i]() as BaseGenerator;\r\n                tmp.process(document)\r\n            }\r\n\r\n            fs.writeFileSync(filePath, document.documentation);\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n}\r\n###\r\n",
		"id": "src\\documentation\\DocumentationGenerator.ts"
	},
	{
		"name": "GenerateOptions.ts",
		"path": "src\\documentation\\plugins\\GenerateOptions.ts",
		"folderPath": "src\\documentation\\plugins",
		"fileContent": "\r\nexport interface GenerateOptions {\r\n    id? : string;\r\n    args?: any\r\n    template?: string;\r\n    name: string;\r\n    pathToFile: string\r\n    folderPath: string\r\n    sidebarPosition?: number\r\n    sidebarLabel?: string\r\n    saveToPath?: string;\r\n    data?: any;\r\n}",
		"documentation": "# GenerateOptions.ts\n\n## Overview\n\nThe `GenerateOptions.ts` file defines an interface called `GenerateOptions`. This interface is used to specify the options for generating content, such as files or templates, in a TypeScript project. The interface includes various properties that can be used to customize the generation process, such as the ID, arguments, template, name, path, and more.\n\n## Usage\n\nTo use the `GenerateOptions` interface in your TypeScript project, you can import it and then create an object that implements the interface. Here are some examples of how to use the `GenerateOptions` interface:\n\n### Example 1: Basic Usage\n\n```typescript\nimport { GenerateOptions } from './GenerateOptions';\n\nconst options: GenerateOptions = {\n  name: 'example',\n  pathToFile: './examples/example.txt',\n  folderPath: './examples',\n};\n```\n\n### Example 2: With Optional Properties\n\n```typescript\nimport { GenerateOptions } from './GenerateOptions';\n\nconst options: GenerateOptions = {\n  id: 'example-1',\n  args: { key: 'value' },\n  template: 'template-name',\n  name: 'example',\n  pathToFile: './examples/example.txt',\n  folderPath: './examples',\n  sidebarPosition: 1,\n  sidebarLabel: 'Example',\n  saveToPath: './output',\n  data: { dataKey: 'dataValue' },\n};\n```\n\n## Properties\n\nThe `GenerateOptions` interface includes the following properties:\n\n### id (optional)\n\n- Type: `string`\n- Description: A unique identifier for the generated content.\n\n### args (optional)\n\n- Type: `any`\n- Description: Additional arguments that can be passed to the generation process.\n\n### template (optional)\n\n- Type: `string`\n- Description: The name of the template to be used for generating the content.\n\n### name\n\n- Type: `string`\n- Description: The name of the generated content.\n\n### pathToFile\n\n- Type: `string`\n- Description: The path to the file that will be generated.\n\n### folderPath\n\n- Type: `string`\n- Description: The path to the folder where the generated file will be saved.\n\n### sidebarPosition (optional)\n\n- Type: `number`\n- Description: The position of the generated content in the sidebar (if applicable).\n\n### sidebarLabel (optional)\n\n- Type: `string`\n- Description: The label for the generated content in the sidebar (if applicable).\n\n### saveToPath (optional)\n\n- Type: `string`\n- Description: The path where the generated content will be saved. If not provided, the content will be saved in the `folderPath`.\n\n### data (optional)\n\n- Type: `any`\n- Description: Additional data that can be used during the generation process.\n\n## Conclusion\n\nThe `GenerateOptions.ts` file provides a flexible and customizable way to define options for generating content in a TypeScript project. By using the `GenerateOptions` interface, developers can easily specify various properties to control the generation process and create content that meets their specific requirements.",
		"isFolder": false,
		"updated": "2023-03-27T19:10:37.712Z",
		"sidebar_position": 0,
		"sidebar_label": "GenerateOptions.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\GenerateOptions.ts"
	},
	{
		"name": "BaseGenerator.ts",
		"path": "src\\documentation\\plugins\\generators\\BaseGenerator.ts",
		"folderPath": "src\\documentation\\plugins\\generators",
		"fileContent": "import Document from \"../../Document\";\r\n\r\n/*\r\nThis is the Base class for Generator plugins. Generator plugins are used to parse the documentation\r\nand modify it for the build tool you are using to build the documentation.\r\n\r\nDefault plugin with code-narrator is Docusaurus since it fails to build when a function contains\r\na Promise<> in return. This plugin clear that Promise from the function name so it can build.\r\nIt also creates sidebar information.\r\n */\r\nexport default abstract class BaseGenerator {\r\n\r\n    abstract process(document : Document) : Document;\r\n}",
		"documentation": "# BaseGenerator.ts\n\n`BaseGenerator.ts` is a TypeScript code file that defines the base class for Generator plugins. Generator plugins are used to parse the documentation and modify it for the build tool you are using to build the documentation.\n\nThe default plugin with code-narrator is Docusaurus since it fails to build when a function contains a `Promise<>` in return. This plugin clears that Promise from the function name so it can build. It also creates sidebar information.\n\n## Usage\n\nTo use this class, you need to create a new class that extends the `BaseGenerator` class and implement the `process` method.\n\n```typescript\nimport BaseGenerator from \"./BaseGenerator\";\nimport Document from \"../../Document\";\n\nclass CustomGenerator extends BaseGenerator {\n    process(document: Document): Document {\n        // Your custom implementation here\n    }\n}\n```\n\n## Methods\n\n### process(document: Document): Document\n\nThis abstract method should be implemented by the derived class. It takes a `Document` object as input and returns a modified `Document` object.\n\n#### Parameters\n\n- `document` (Document): The input `Document` object that needs to be processed by the generator plugin.\n\n#### Returns\n\n- `Document`: The modified `Document` object after processing.\n\n## Technical Concepts\n\n### Generator Plugins\n\nGenerator plugins are used to parse and modify the documentation for the build tool you are using to build the documentation. They can be used to customize the output of the documentation, such as modifying the function names, creating sidebar information, or adding additional metadata.\n\n### Promise\n\nA `Promise` is a standard JavaScript object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. In the context of this file, the `Promise<>` type is used to indicate that a function returns a promise that resolves to a specific type. However, Docusaurus fails to build when a function contains a `Promise<>` in return, so the generator plugin clears that Promise from the function name to allow the build to proceed.",
		"isFolder": false,
		"updated": "2023-03-27T19:11:23.697Z",
		"sidebar_position": 0,
		"sidebar_label": "BaseGenerator.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\generators",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\generators\\BaseGenerator.ts"
	},
	{
		"name": "DocusaurusGenerator.ts",
		"path": "src\\documentation\\plugins\\generators\\Docusaurus\\DocusaurusGenerator.ts",
		"folderPath": "src\\documentation\\plugins\\generators\\Docusaurus",
		"fileContent": "import BaseGenerator from \"../BaseGenerator\";\r\nimport Document from '../../../Document'\r\nexport default class DocusaurusGenerator extends BaseGenerator {\r\n\r\n    public process(document : Document) {\r\n        //docusaurus does not like to have Promise<> in its headers, so let's remove them\r\n        document.documentation = document.documentation.replaceAll(/: Promise<[a-zA-Z]*>/gm, '').trim();\r\n\r\n        let sidebar_label = (document.sidebar_label) ? document.sidebar_label : document.name;\r\n        let position = document.sidebar_position ?? 1;\r\n        document.documentation = `---\r\nsidebar_position: ${position}\r\nsidebar_label: ${sidebar_label}\r\n---\r\n\r\n` + document.documentation;\r\n        return document;\r\n    }\r\n\r\n}",
		"documentation": "# DocusaurusGenerator.ts\n\nDocusaurusGenerator.ts is a TypeScript file that extends the BaseGenerator class and provides a specific implementation for generating documentation compatible with Docusaurus, a popular static site generator for documentation websites.\n\n## Usage\n\nTo use the DocusaurusGenerator class, you need to import it and create an instance. Then, you can call the `process` method on the instance, passing a Document object as a parameter.\n\n```typescript\nimport DocusaurusGenerator from './DocusaurusGenerator';\nimport Document from '../../../Document';\n\nconst generator = new DocusaurusGenerator();\nconst document = new Document(/* ... */);\n\nconst processedDocument = generator.process(document);\n```\n\n## Class: DocusaurusGenerator\n\n### Method: process(document: Document)\n\nThis method takes a Document object as input and processes it to make it compatible with Docusaurus. It returns the processed Document object.\n\n#### Parameters\n\n- `document: Document` - The Document object to be processed.\n\n#### Description\n\nThe `process` method performs the following operations on the input Document object:\n\n1. Removes any occurrences of `: Promise<[a-zA-Z]*>` from the documentation, as Docusaurus does not support Promise types in headers.\n2. Sets the `sidebar_label` property of the document to either the provided `sidebar_label` or the document's name if no `sidebar_label` is provided.\n3. Sets the `sidebar_position` property of the document to the provided `sidebar_position` or 1 if no `sidebar_position` is provided.\n4. Prepends the Docusaurus-specific frontmatter (sidebar_position and sidebar_label) to the documentation.\n\nAfter processing, the method returns the modified Document object.\n\n## Example\n\n```typescript\nimport DocusaurusGenerator from './DocusaurusGenerator';\nimport Document from '../../../Document';\n\nconst generator = new DocusaurusGenerator();\nconst document = new Document({\n  name: 'Example',\n  documentation: 'This is an example document.',\n  sidebar_label: 'Example Label',\n  sidebar_position: 2,\n});\n\nconst processedDocument = generator.process(document);\nconsole.log(processedDocument.documentation);\n```\n\nOutput:\n\n```\n---\nsidebar_position: 2\nsidebar_label: Example Label\n---\n\nThis is an example document.\n```",
		"isFolder": false,
		"updated": "2023-03-27T19:12:22.339Z",
		"sidebar_position": 0,
		"sidebar_label": "DocusaurusGenerator.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\generators\\Docusaurus",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\generators\\Docusaurus\\DocusaurusGenerator.ts"
	},
	{
		"name": "OpenAIRepository.ts",
		"path": "src\\repositories\\OpenAIRepository.ts",
		"folderPath": "src\\repositories",
		"fileContent": "import {ChatCompletionRequestMessage, Configuration, CreateCompletionResponseChoicesInner, OpenAIApi} from 'openai';\r\nimport ConfigHelper from \"../utils/ConfigHelper\";\r\nimport { setTimeout } from 'timers/promises';\r\nimport {CreateChatCompletionResponseChoicesInner} from \"openai/api\";\r\nimport config from '../../code-narrator.config'\r\n\r\nexport default class OpenAIRepository {\r\n    openai: OpenAIApi;\r\n    constructor() {\r\n        const configuration = new Configuration({\r\n            apiKey: ConfigHelper.get('OPENAI_API_KEY')\r\n        });\r\n        this.openai = new OpenAIApi(configuration);\r\n    }\r\n\r\n\r\n    public async query(text : string) : Promise<CreateCompletionResponseChoicesInner[] | undefined> {\r\n        return this.queryQuestions([text]);\r\n    }\r\n    public async queryQuestions(questions : string[], errorCount = 0, model = 'gpt-4'): Promise<CreateChatCompletionResponseChoicesInner[] | undefined> {\r\n        try {\r\n            await setTimeout(1 * 1000);\r\n\r\n            let messages : ChatCompletionRequestMessage[] = []\r\n            let messageLength = 0;\r\n            for (let i=0;config.gptSystemCommands && i<config.gptSystemCommands.length;i++) {\r\n                messages.push({role:'system', content:config.gptSystemCommands[i].replace('{DocumentationType}', ConfigHelper.DocumentationType)})\r\n            }\r\n            for (let i=0;i<questions.length;i++){\r\n                messages.push({role:'user', content:questions[i]})\r\n                messageLength += questions[i].length;\r\n            }\r\n            let maxTokens = (model.indexOf('gpt-4') != -1) ? 8000 : 4000;\r\n            const completion = await this.openai.createChatCompletion({\r\n                model: model,\r\n                messages : messages,\r\n                temperature: 0.1,\r\n                max_tokens: maxTokens - messageLength,\r\n                top_p: 1,\r\n                frequency_penalty: 0,\r\n                presence_penalty: 0\r\n\r\n            });\r\n            return completion.data.choices;\r\n        } catch (e : any) {\r\n            if (e?.response?.data?.error && e.response.data.error.message.indexOf('You exceeded your current quota') != -1) {\r\n                throw new Error(e.response.data.error.message);\r\n            }\r\n\r\n            if (e && this.retryStatuses.includes(e.response?.status) && errorCount < 3) {\r\n                console.log('Sleep 3 sec')\r\n                await setTimeout(3 * 1000);\r\n                return this.queryQuestions(questions, ++errorCount, model);\r\n            }\r\n\r\n            console.error('OpenAI error:', e.response.data.error.message)\r\n            console.error('Error doing OpenAI query:', questions);\r\n            console.error(e);\r\n            return;\r\n            //throw e;\r\n        }\r\n    }\r\n\r\n    retryStatuses = [429, 500, 503]\r\n}",
		"documentation": "# OpenAIRepository.ts\n\nThis TypeScript file defines the `OpenAIRepository` class, which is responsible for interacting with the OpenAI API. The class provides methods to query the API using the GPT-4 model and handle errors and retries.\n\n## Usage\n\nTo use the `OpenAIRepository` class, first import it and create an instance:\n\n```typescript\nimport OpenAIRepository from './OpenAIRepository';\n\nconst openAIRepo = new OpenAIRepository();\n```\n\nThen, you can use the `query` or `queryQuestions` methods to interact with the OpenAI API:\n\n```typescript\nconst response = await openAIRepo.query('What is the meaning of life?');\n```\n\n## Class Methods\n\n### constructor()\n\nThe constructor initializes the `OpenAIRepository` instance by creating a new `OpenAIApi` object with the provided API key from the configuration.\n\n### query(text: string): Promise<CreateCompletionResponseChoicesInner[] | undefined>\n\nThis method takes a single question as a string and returns a Promise that resolves to an array of `CreateCompletionResponseChoicesInner` objects or `undefined` if an error occurs. It internally calls the `queryQuestions` method with the provided question.\n\n### queryQuestions(questions: string[], errorCount = 0, model = 'gpt-4'): Promise<CreateChatCompletionResponseChoicesInner[] | undefined>\n\nThis method takes an array of questions, an optional error count, and an optional model name (defaulting to 'gpt-4'). It returns a Promise that resolves to an array of `CreateChatCompletionResponseChoicesInner` objects or `undefined` if an error occurs.\n\nThe method handles retries in case of specific error statuses (429, 500, 503) and sleeps for a certain amount of time before retrying. It also throws an error if the quota for the API is exceeded.\n\n## Technical Concepts\n\n### OpenAIApi and Configuration\n\nThe `OpenAIApi` and `Configuration` classes are imported from the `openai` package. They are used to create an instance of the OpenAI API with the provided API key and configuration.\n\n### ConfigHelper\n\nThe `ConfigHelper` class is a utility class that helps in fetching configuration values from the `code-narrator.config` file.\n\n### setTimeout\n\nThe `setTimeout` function is imported from the `timers/promises` package and is used to create a delay before retrying the API call in case of specific error statuses.\n\n### CreateCompletionResponseChoicesInner and CreateChatCompletionResponseChoicesInner\n\nThese types are imported from the `openai` package and represent the response choices returned by the OpenAI API.",
		"isFolder": false,
		"updated": "2023-03-28T10:41:58.193Z",
		"sidebar_position": 0,
		"sidebar_label": "OpenAIRepository.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\repositories",
		"documentation_type": "md",
		"id": "src\\repositories\\OpenAIRepository.ts"
	},
	{
		"name": "ConfigHelper.ts",
		"path": "src\\utils\\ConfigHelper.ts",
		"folderPath": "src\\utils",
		"fileContent": "import * as dotnet from \"dotenv\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport App from \"../App\";\r\n\r\nexport default class ConfigHelper {\r\n    static env : any;\r\n    static cn : any;\r\n    static projectFile : any;\r\n    static BuilderPlugins : any[] = [];\r\n    static DocumentationType = 'md';\r\n    static DocumentExtension = '.md';\r\n    static CacheFilePath = '.code-narrator/cache.json';\r\n    public static async load(config : any, project : any) {\r\n        dotnet.config()\r\n        ConfigHelper.env = process.env;\r\n        ConfigHelper.cn = project;\r\n        ConfigHelper.BuilderPlugins = config.builderPlugins;\r\n        ConfigHelper.DocumentExtension = config.document_file_extension ?? '.md';\r\n        ConfigHelper.DocumentationType = config.documentation_type ?? 'md'\r\n        if (ConfigHelper.DocumentExtension.indexOf('.') != 0) ConfigHelper.DocumentExtension = '.' + ConfigHelper.DocumentExtension;\r\n\r\n        ConfigHelper.CacheFilePath = config.cache_file ?? '.code-narrator/cache.json';\r\n\r\n        let projectFile = ConfigHelper.get('project_file');\r\n        const projectFileRaw = fs.readFileSync(path.join(process.cwd(), projectFile));\r\n        ConfigHelper.projectFile = JSON.parse(projectFileRaw.toString());\r\n        if (ConfigHelper.projectFile['repository']) {\r\n            App.repositoryUrl = ConfigHelper.projectFile['repository']['url']\r\n        }\r\n    }\r\n    public static get(key : string) {\r\n        let value = ConfigHelper.env[key];\r\n        if (value) return value;\r\n        value = ConfigHelper.cn[key] ?? '';\r\n        if (value) return value;\r\n        return ConfigHelper.projectFile[key] ?? '';\r\n    }\r\n\r\n}",
		"documentation": "# ConfigHelper.ts\n\n## Overview\n\nThe `ConfigHelper.ts` file is a TypeScript module that provides a utility class, `ConfigHelper`, for managing and accessing configuration settings in a project. This class is responsible for loading configuration settings from various sources, such as environment variables, project configuration files, and cache files. It also provides a method for retrieving configuration values by key.\n\n## Usage\n\nTo use the `ConfigHelper` class, first import it into your TypeScript file:\n\n```typescript\nimport ConfigHelper from \"./ConfigHelper\";\n```\n\nThen, call the `load` method to load the configuration settings:\n\n```typescript\nawait ConfigHelper.load(config, project);\n```\n\nFinally, use the `get` method to retrieve configuration values by key:\n\n```typescript\nconst value = ConfigHelper.get(\"key\");\n```\n\n## Methods\n\n### load(config: any, project: any): Promise<void>\n\nThis asynchronous method loads configuration settings from various sources, such as environment variables, project configuration files, and cache files. It takes two parameters:\n\n- `config`: An object containing configuration settings.\n- `project`: An object containing project settings.\n\n### get(key: string): any\n\nThis method retrieves a configuration value by key. It first checks the environment variables, then the project settings, and finally the project file. If the key is not found in any of these sources, it returns an empty string. It takes one parameter:\n\n- `key`: The key of the configuration value to retrieve.\n\n## Properties\n\n- `env`: An object containing environment variables.\n- `cn`: An object containing project settings.\n- `projectFile`: An object containing the parsed contents of the project file.\n- `BuilderPlugins`: An array of builder plugins.\n- `DocumentationType`: A string representing the documentation type (default: 'md').\n- `DocumentExtension`: A string representing the document file extension (default: '.md').\n- `CacheFilePath`: A string representing the cache file path (default: '.code-narrator/cache.json').\n\n## Technical Concepts\n\n### dotenv\n\nThe `dotenv` module is used to load environment variables from a `.env` file into `process.env`. This allows the application to access environment variables in a consistent manner across different environments.\n\n### JSON.parse\n\nThe `JSON.parse` method is used to parse the contents of the project file, which is expected to be in JSON format. This method converts the JSON string into a JavaScript object, which can then be accessed and manipulated by the application.",
		"isFolder": false,
		"updated": "2023-03-27T19:14:26.705Z",
		"sidebar_position": 0,
		"sidebar_label": "ConfigHelper.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\utils",
		"documentation_type": "md",
		"id": "src\\utils\\ConfigHelper.ts"
	},
	{
		"name": "FileStructure.ts",
		"path": "src\\utils\\FileStructure.ts",
		"folderPath": "src\\utils",
		"fileContent": "import path, {resolve} from \"path\";\r\nimport fs from \"fs\";\r\nimport ConfigHelper from \"./ConfigHelper\";\r\n\r\nexport default class FileStructure {\r\n    name = '';\r\n    path = '';\r\n    entry : any;\r\n\r\n    constructor(dir : string, entry : any) {\r\n        this.name = entry.name;\r\n        let project_path = ConfigHelper.get('project_path');\r\n        this.path = path.relative(project_path, resolve(dir, entry.name));\r\n        this.entry = entry;\r\n    }\r\n\r\n    public static isCodeFile(fileName: string) {\r\n        return path.extname(fileName).indexOf('.ts') != -1;\r\n    }\r\n\r\n\r\n    static getContent(path: string) : string {\r\n        if (!fs.existsSync(path)) return '';\r\n\r\n        return fs.readFileSync(path).toString();\r\n    }\r\n}",
		"documentation": "# FileStructure.ts\n\n## Overview\n\nThe `FileStructure.ts` file is a TypeScript module that provides a class named `FileStructure`. This class is responsible for managing file structures, specifically for code files with the `.ts` (TypeScript) extension. It provides methods for creating a new instance of the class, checking if a file is a code file, and retrieving the content of a file.\n\n## Usage\n\nTo use the `FileStructure` class, you need to import it into your TypeScript code:\n\n```typescript\nimport FileStructure from \"./FileStructure\";\n```\n\n### Creating a new instance\n\nTo create a new instance of the `FileStructure` class, you need to provide a directory path and an entry object:\n\n```typescript\nconst dir = \"/path/to/directory\";\nconst entry = { name: \"example.ts\" };\nconst fileStructure = new FileStructure(dir, entry);\n```\n\n### Checking if a file is a code file\n\nTo check if a file is a code file (TypeScript), you can use the `isCodeFile` static method:\n\n```typescript\nconst fileName = \"example.ts\";\nconst isCodeFile = FileStructure.isCodeFile(fileName);\nconsole.log(isCodeFile); // true\n```\n\n### Retrieving the content of a file\n\nTo get the content of a file, you can use the `getContent` static method:\n\n```typescript\nconst filePath = \"/path/to/file/example.ts\";\nconst content = FileStructure.getContent(filePath);\nconsole.log(content); // Content of the file\n```\n\n## Class Methods\n\n### constructor(dir: string, entry: any)\n\nThe constructor method initializes a new instance of the `FileStructure` class. It takes two parameters:\n\n- `dir` (string): The directory path where the file is located.\n- `entry` (any): An object containing the file's name.\n\n### isCodeFile(fileName: string): boolean\n\nThis static method checks if a given file is a TypeScript code file. It takes one parameter:\n\n- `fileName` (string): The name of the file to check.\n\nIt returns a boolean value indicating whether the file is a TypeScript code file or not.\n\n### getContent(path: string): string\n\nThis static method retrieves the content of a file. It takes one parameter:\n\n- `path` (string): The path to the file.\n\nIt returns a string containing the content of the file. If the file does not exist, it returns an empty string.\n\n## Technical Concepts\n\n### ConfigHelper\n\nThe `ConfigHelper` class is imported from the `./ConfigHelper` module. It is used to get the project path from the configuration. This is not a standard concept, but it is used in the `FileStructure` class to resolve the relative path of the file.",
		"isFolder": false,
		"updated": "2023-03-27T19:15:25.924Z",
		"sidebar_position": 1,
		"sidebar_label": "FileStructure.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\utils",
		"documentation_type": "md",
		"id": "src\\utils\\FileStructure.ts"
	},
	{
		"name": "FolderStructure.ts",
		"path": "src\\utils\\FolderStructure.ts",
		"folderPath": "src\\utils",
		"fileContent": "import fs, {existsSync, readdirSync} from \"fs\";\r\nimport FileStructure from \"./FileStructure\";\r\nimport ConfigHelper from \"./ConfigHelper\";\r\nimport path, {resolve} from \"path\";\r\nimport Ignore from 'ignore';\r\nimport App from \"../App\";\r\nexport default class FolderStructure {\r\n\r\n    name = '';\r\n    path = '';\r\n    entry : any;\r\n    files : FileStructure[];\r\n    folders : FolderStructure[];\r\n\r\n    constructor(folderPath : string) {\r\n        let project_path = ConfigHelper.get('project_path');\r\n        this.path = path.relative(project_path, folderPath);\r\n\r\n        this.name = path.basename(this.path);\r\n\r\n        this.files = this.getFiles(folderPath);\r\n        this.folders = this.getStructure(folderPath);\r\n    }\r\n\r\n    public static getFiles(dir : string) {\r\n        const entries = readdirSync(dir, {withFileTypes: true});\r\n        let files :FileStructure[] = [];\r\n        for (const entry of entries) {\r\n            if (!entry.isDirectory() && !FolderStructure.isInIgnoreList(entry.name)) {\r\n                files.push(new FileStructure(dir, entry))\r\n            }\r\n        }\r\n        return files;\r\n    }\r\n\r\n    public static exists(dir : string) : boolean {\r\n        return existsSync(dir);\r\n    }\r\n    public getFiles(dir: string): FileStructure[] {\r\n        return FolderStructure.getFiles(dir);\r\n    }\r\n\r\n    private getStructure(path: string) : FolderStructure[] {\r\n        let folders : FolderStructure[] = [];\r\n        const entries = readdirSync(path, {withFileTypes: true});\r\n        for (const entry of entries) {\r\n            const res = resolve(path, entry.name);\r\n            if (entry.isDirectory() && !FolderStructure.isInIgnoreList(res)) {\r\n                folders.push(new FolderStructure(res));\r\n            }\r\n        }\r\n        return folders;\r\n    }\r\n\r\n\r\n\r\n    public static isInIgnoreList(fileOrFolderPath : string): boolean {\r\n        let relativePath = path.relative(App.Project.project_path, fileOrFolderPath)\r\n        if (relativePath == '') return false;\r\n\r\n        const ignore = Ignore();\r\n        const excludedPatterns = ConfigHelper.get('exclude') as string[];\r\n        ignore.add(excludedPatterns);\r\n        return ignore.ignores(relativePath);\r\n    }\r\n\r\n    public static searchForStringInFiles(root: string, search: string): string {\r\n        const files = fs.readdirSync(root);\r\n\r\n        for (const file of files) {\r\n            const fullPath = path.join(root, file);\r\n            const stats = fs.statSync(fullPath);\r\n\r\n            if (stats.isDirectory()) {\r\n                return FolderStructure.searchForStringInFiles(fullPath, search);\r\n            } else {\r\n                if (path.extname(fullPath) === '.ts' || path.extname(fullPath) === '.js') {\r\n                    const content = fs.readFileSync(fullPath, 'utf-8');\r\n                    if (content.includes(search)) {\r\n                        console.log(`${fullPath} contains the search string '${search}'`);\r\n                        return content;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return '';\r\n    }\r\n}",
		"documentation": "# FolderStructure.ts\n\n## Overview\n\nThe `FolderStructure.ts` file is a TypeScript module that provides a class called `FolderStructure`. This class is responsible for managing and interacting with folder structures in a file system. It provides methods for getting files, checking if a folder exists, searching for a string in files, and more.\n\n## Usage\n\nTo use the `FolderStructure` class, you need to import it and create an instance by passing the folder path as a parameter:\n\n```typescript\nimport FolderStructure from './FolderStructure';\n\nconst folder = new FolderStructure('/path/to/folder');\n```\n\n## Class: FolderStructure\n\n### Properties\n\n- `name`: The name of the folder.\n- `path`: The relative path of the folder.\n- `entry`: An entry object representing the folder.\n- `files`: An array of `FileStructure` objects representing the files in the folder.\n- `folders`: An array of `FolderStructure` objects representing the subfolders in the folder.\n\n### Constructor\n\n- `constructor(folderPath: string)`: Initializes a new instance of the `FolderStructure` class with the given folder path.\n\n### Methods\n\n- `static getFiles(dir: string)`: Returns an array of `FileStructure` objects representing the files in the specified directory. It ignores files and folders listed in the ignore list.\n\n- `static exists(dir: string)`: Returns a boolean indicating whether the specified directory exists.\n\n- `getFiles(dir: string)`: Instance method that calls the static `getFiles` method with the specified directory.\n\n- `private getStructure(path: string)`: Returns an array of `FolderStructure` objects representing the subfolders in the specified path. It ignores files and folders listed in the ignore list.\n\n- `static isInIgnoreList(fileOrFolderPath: string)`: Returns a boolean indicating whether the specified file or folder path is in the ignore list.\n\n- `static searchForStringInFiles(root: string, search: string)`: Searches for a specified string in all `.ts` and `.js` files within the specified root directory and its subdirectories. Returns the content of the first file containing the search string and logs the file path.\n\n## Technical Concepts\n\n### Ignore List\n\nThe ignore list is a list of file and folder patterns that should be excluded from certain operations, such as getting files or searching for a string in files. The ignore list is managed using the `ignore` package and can be configured using the `ConfigHelper` class.",
		"isFolder": false,
		"updated": "2023-03-28T11:32:34.987Z",
		"sidebar_position": 2,
		"sidebar_label": "FolderStructure.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\utils",
		"documentation_type": "md",
		"id": "src\\utils\\FolderStructure.ts"
	},
	{
		"name": "Helper.ts",
		"path": "src\\utils\\Helper.ts",
		"folderPath": "src\\utils",
		"fileContent": "const extract = require('extract-json-from-string');\r\n\r\nexport default class Helper {\r\n\r\n    public static removeExtension(fileName : string) {\r\n        if (fileName.lastIndexOf(\".\") == -1) return fileName;\r\n\r\n        let name = fileName.substring(0, fileName.lastIndexOf(\".\"));\r\n        if (name == '') return fileName;\r\n        return name;\r\n    }\r\n\r\n    static upperFirstLetter(name: string) {\r\n        return name.charAt(0).toUpperCase() + name.slice(1);\r\n    }\r\n\r\n    static getJsons(content : string) : any[] {\r\n        return extract(content)\r\n    }\r\n}",
		"documentation": "# Helper.ts\n\nThis is a TypeScript code file that contains a utility class called `Helper`. The `Helper` class provides various utility methods that can be used throughout your application. These methods include removing file extensions, capitalizing the first letter of a string, and extracting JSON objects from a string.\n\n## Usage\n\nTo use the `Helper` class, simply import it into your TypeScript file and call the desired static methods.\n\n```typescript\nimport Helper from './Helper';\n\nconst fileName = 'example.txt';\nconst noExtension = Helper.removeExtension(fileName);\nconsole.log(noExtension); // Output: example\n\nconst name = 'john';\nconst capitalized = Helper.upperFirstLetter(name);\nconsole.log(capitalized); // Output: John\n\nconst jsonString = '{\"key\": \"value\"}';\nconst jsonObjects = Helper.getJsons(jsonString);\nconsole.log(jsonObjects); // Output: [{ key: 'value' }]\n```\n\n## Methods\n\n### removeExtension(fileName: string)\n\nThis method takes a `fileName` string as a parameter and returns the file name without its extension.\n\n#### Parameters\n\n- `fileName` (string): The file name with its extension.\n\n### upperFirstLetter(name: string)\n\nThis method takes a `name` string as a parameter and returns the same string with the first letter capitalized.\n\n#### Parameters\n\n- `name` (string): The string to capitalize the first letter of.\n\n### getJsons(content: string)\n\nThis method takes a `content` string as a parameter and returns an array of JSON objects extracted from the string.\n\n#### Parameters\n\n- `content` (string): The string containing JSON objects.\n\n## Technical Concepts\n\n- **TypeScript**: TypeScript is a superset of JavaScript that adds optional static types to the language. It is designed to make it easier to write and maintain large-scale JavaScript applications.\n\n- **Static methods**: Static methods are methods that belong to a class rather than an instance of the class. They can be called directly on the class itself, without needing to create an instance of the class.\n\n- **JSON**: JSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. JSON is a text format that is completely language-independent but uses conventions that are familiar to programmers of the C family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others.",
		"isFolder": false,
		"updated": "2023-03-27T19:17:34.962Z",
		"sidebar_position": 3,
		"sidebar_label": "Helper.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\utils",
		"documentation_type": "md",
		"id": "src\\utils\\Helper.ts"
	},
	{
		"name": "ProjectStructure.ts",
		"path": "src\\utils\\ProjectStructure.ts",
		"folderPath": "src\\utils",
		"fileContent": "import ConfigHelper from \"../utils/ConfigHelper\";\r\nimport FolderStructure from \"../utils/FolderStructure\";\r\n\r\nexport default class ProjectStructure {\r\n    public async getStructure() {\r\n        let projectPath = ConfigHelper.get('project_path')!;\r\n        let folderStructure = new FolderStructure(projectPath);\r\n\r\n        return folderStructure;\r\n    }\r\n\r\n}",
		"documentation": "# ProjectStructure.ts\n\n## Overview\n\nThe `ProjectStructure.ts` file is a TypeScript module that exports a `ProjectStructure` class. This class is responsible for managing the structure of a project, including its folder hierarchy and configuration settings. It utilizes the `ConfigHelper` and `FolderStructure` utility classes to achieve this.\n\n## Usage\n\nTo use the `ProjectStructure` class, you first need to import it:\n\n```typescript\nimport ProjectStructure from \"./ProjectStructure\";\n```\n\nThen, create a new instance of the class and call its methods as needed:\n\n```typescript\nconst projectStructure = new ProjectStructure();\nconst structure = await projectStructure.getStructure();\n```\n\n## Class: ProjectStructure\n\n### Method: getStructure()\n\nThis method retrieves the folder structure of the project, based on the project path specified in the configuration.\n\n#### Parameters\n\nThere are no parameters for this method.\n\n#### Returns\n\nThis method returns an instance of the `FolderStructure` class, which represents the folder hierarchy of the project.\n\n#### Example\n\n```typescript\nconst projectStructure = new ProjectStructure();\nconst structure = await projectStructure.getStructure();\nconsole.log(structure);\n```\n\n## Utility Classes\n\n### ConfigHelper\n\nThe `ConfigHelper` utility class is used to manage the configuration settings of the project. It provides methods to get and set configuration values, such as the project path.\n\n### FolderStructure\n\nThe `FolderStructure` utility class is used to represent and manipulate the folder hierarchy of the project. It provides methods to traverse the folder structure, create new folders, and delete existing ones.\n\n## Technical Concepts\n\n### TypeScript\n\nTypeScript is a superset of JavaScript that adds optional static typing to the language. It is designed to make it easier to write and maintain large-scale JavaScript applications. TypeScript code is transpiled to JavaScript before being executed in the browser or on the server.\n\n### JSON\n\nJSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. It is a text format that is completely language-independent but uses conventions that are familiar to programmers of the C family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others.",
		"isFolder": false,
		"updated": "2023-03-27T19:18:40.515Z",
		"sidebar_position": 4,
		"sidebar_label": "ProjectStructure.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\utils",
		"documentation_type": "md",
		"id": "src\\utils\\ProjectStructure.ts"
	},
	{
		"name": "Docusaurus",
		"path": "src\\documentation\\plugins\\generators\\Docusaurus",
		"folderPath": "src\\documentation\\plugins\\generators\\Docusaurus",
		"fileContent": "",
		"documentation": "# Docusaurus\n\nThis folder is responsible for generating documentation compatible with Docusaurus, a popular static site generator for documentation websites. The content of this folder includes the following files and folders:\n\n## [DocusaurusGenerator.ts](DocusaurusGenerator.ts)\n\nDocusaurusGenerator.ts is a TypeScript file that extends the BaseGenerator class and provides a specific implementation for generating documentation compatible with Docusaurus.\n\n### Usage\n\nFor more information on how to use DocusaurusGenerator.ts, please refer to its [documentation](DocusaurusGenerator.ts).\n\n---\n\nFor more information and the source code, visit the [repository](https://github.com/ingig/code-narrator/src/documentation/plugins/generators/Docusaurus).",
		"isFolder": true,
		"updated": "2023-03-27T19:20:02.148Z",
		"sidebar_position": 30,
		"sidebar_label": "Docusaurus",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation\\plugins\\generators\\Docusaurus",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\generators\\Docusaurus"
	},
	{
		"name": "documentation",
		"path": "src\\documentation",
		"folderPath": "src\\documentation",
		"fileContent": "",
		"documentation": "# Documentation\n\nThis documentation provides an in-depth overview of the contents of the folder and their respective roles in the system. The folder is divided into sections with clear headings and subheadings.\n\n## Table of Contents\n\n1. [Document.ts](#documentts)\n2. [DocumentationBuilder.ts](#documentationbuilderts)\n3. [DocumentationCache.ts](#documentationcachets)\n4. [DocumentationGenerator.ts](#documentationgeneratorts)\n5. [Plugins](#plugins)\n\n### Document.ts\n\n[# Document.ts](Document.ts)\n\n#### Overview\n\nThe Document.ts file is responsible for managing the structure and content of the documentation. It provides the necessary functionality to create, edit, and update the documentation.\n\n### DocumentationBuilder.ts\n\n[# DocumentationBuilder.ts](DocumentationBuilder.ts)\n\n#### Overview\n\nThe DocumentationBuilder.ts file is responsible for building the documentation from the provided JSON data. It processes the data and generates the appropriate sections, headings, and subheadings for the documentation.\n\n### DocumentationCache.ts\n\n[# DocumentationCache.ts](DocumentationCache.ts)\n\n#### Overview\n\nThe DocumentationCache.ts file is responsible for caching the generated documentation. It stores the documentation in a cache to improve performance and reduce the need for redundant processing.\n\n### DocumentationGenerator.ts\n\n[# DocumentationGenerator.ts](DocumentationGenerator.ts)\n\n#### Overview\n\nThe DocumentationGenerator.ts file is responsible for generating the documentation from the provided JSON data. It processes the data and generates the appropriate sections, headings, and subheadings for the documentation.\n\n### Plugins\n\n[# Plugins](plugins)\n\nThis folder is responsible for managing the plugins used in the system. The plugins are divided into different sections, each with a specific purpose and functionality. This documentation provides a high-level overview of the contents of the plugins folder and their respective roles.\n\n#### Table of Contents\n\n* [Plugin 1](#plugin-1)\n* [Plugin 2](#plugin-2)\n* [Plugin 3](#plugin-3)\n\n[Link to Repository](https://github.com/ingig/code-narrator/src/documentation)",
		"isFolder": true,
		"updated": "2023-03-27T19:21:54.879Z",
		"sidebar_position": 30,
		"sidebar_label": "Documentation",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation",
		"documentation_type": "md",
		"id": "src\\documentation"
	},
	{
		"name": "repositories",
		"path": "src\\repositories",
		"folderPath": "src\\repositories",
		"fileContent": "",
		"documentation": "# Repositories\n\nThis folder contains the necessary files and classes to interact with various APIs and services. The main purpose of this folder is to provide a centralized location for managing data access and communication with external services.\n\n## Files and Folders\n\n### [OpenAIRepository.ts](src\\repositories\\OpenAIRepository.ts)\n\nThis TypeScript file defines the `OpenAIRepository` class, which is responsible for interacting with the OpenAI API. The class provides methods to query the API using different models and handles errors and retries.\n\n#### Class: OpenAIRepository\n\nThe `OpenAIRepository` class provides methods for interacting with the OpenAI API, such as querying the API using different models, handling errors, and managing retries. For more information, refer to the [OpenAIRepository.ts documentation](src\\repositories\\OpenAIRepository.ts).\n\n## Repository Link\n\nFor the complete repository, visit [https://github.com/ingig/code-narrator/src/repositories](https://github.com/ingig/code-narrator/src/repositories).",
		"isFolder": true,
		"updated": "2023-03-27T19:22:19.898Z",
		"sidebar_position": 31,
		"sidebar_label": "Repositories",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\repositories",
		"documentation_type": "md",
		"id": "src\\repositories"
	},
	{
		"name": "utils",
		"path": "src\\utils",
		"folderPath": "src\\utils",
		"fileContent": "",
		"documentation": "# Utils\n\nThe `utils` folder is responsible for providing various utility functions and classes that can be used throughout the system. This folder contains the following files:\n\n- [ConfigHelper.ts](#confighelperts)\n- [FileStructure.ts](#filestructurets)\n- [FolderStructure.ts](#folderstructurets)\n- [Helper.ts](#helperts)\n- [ProjectStructure.ts](#projectstructurets)\n\n## ConfigHelper.ts\n\n### Overview\n\n`ConfigHelper.ts` is a utility file that provides functions to manage and manipulate configuration settings within the system.\n\n[Read more about ConfigHelper.ts](ConfigHelper.ts)\n\n## FileStructure.ts\n\n### Overview\n\n`FileStructure.ts` is a utility file that provides functions to manage and manipulate file structures within the system.\n\n[Read more about FileStructure.ts](FileStructure.ts)\n\n## FolderStructure.ts\n\n### Overview\n\n`FolderStructure.ts` is a utility file that provides functions to manage and manipulate folder structures within the system.\n\n[Read more about FolderStructure.ts](FolderStructure.ts)\n\n## Helper.ts\n\n### Overview\n\n`Helper.ts` is a TypeScript code file that contains a utility class called `Helper`. The `Helper` class provides various utility methods that can be used throughout your application. These methods include removing file extensions, capitalizing the first letter of a string, and extracting JSON objects from a string.\n\n### Usage\n\n[Read more about Helper.ts](Helper.ts)\n\n## ProjectStructure.ts\n\n### Overview\n\n`ProjectStructure.ts` is a utility file that provides functions to manage and manipulate the overall project structure within the system.\n\n[Read more about ProjectStructure.ts](ProjectStructure.ts)\n\n---\n\n[View the repository on GitHub](https://github.com/ingig/code-narrator/src/utils)",
		"isFolder": true,
		"updated": "2023-03-27T19:23:04.663Z",
		"sidebar_position": 32,
		"sidebar_label": "Utils",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\utils",
		"documentation_type": "md",
		"id": "src\\utils"
	},
	{
		"name": "ReadMe",
		"path": "",
		"folderPath": "./",
		"fileContent": "",
		"documentation": "# code-narrator\n\ncode-narrator is a self-documenting tool that uses OpenAI to generate documentation on code and tests. It is a friend to the lazy developer and should be a validation of the documentation working, similar to a compiler compiling itself. Use the `code-narrator.config.ts` file to set the configuration for your project, such as project path, doc, documentation type, and more.\n\n## Installation\n\nTo install the project, run:\n\n```\nnpm i code-narrator\n```\n\n## Configuration\n\nConfigure the project using the `code-narrator.config.ts` file. Here's an example configuration:\n\n```typescript\nexport default {\n    projects : [{\n        // ...\n    }],\n    builderPlugins : [\n        // ...\n    ],\n    generatorPlugin : [\n        // ...\n    ],\n    systemCommands : [\n        // ...\n    ],\n    documentation_type: 'md',\n    document_file_extension: \".md\",\n    cache_file : '.code-narrator/cache.json'\n};\n```\n\n:::danger\nMake sure to commit the `.code-narrator/cache.json` file into git.\n:::\n\n## Running the Project\n\nTo run the project, execute:\n\n```\nnpm run start\n```\n\nor use the CLI:\n\n```\ncode-narrator-cli\n```\n\n## Running Tests\n\nTo run tests for the project, execute:\n\n```\nnpm test\n```\n\n## Support and Repository\n\n- Post bugs and issues on the [GitHub Issues page](https://github.com/ingig/code-narrator/issues).\n- Visit the [project homepage](https://github.com/ingig/code-narrator) for more information.\n- Access the [repository](https://github.com/ingig/code-narrator).\n\n## Dependencies\n\n- asynckit: ^0.4.0\n- axios: ^0.26.1\n- combined-stream: ^1.0.8\n- delayed-stream: ^1.0.0\n- dotenv: ^16.0.3\n- extract-json-from-string: ^1.0.1\n- follow-redirects: ^1.15.2\n- form-data: ^4.0.0\n- liquidjs: ^10.7.0\n- mime-db: ^1.52.0\n- mime-types: ^2.1.35\n- openai: ^3.1.0\n- @babel/preset-typescript: ^7.21.0\n- @jest/globals: ^29.5.0\n- @types/jest: ^29.4.0\n- @types/node: ^18.11.19\n- jest: ^29.4.2\n- ts-jest: ^29.0.5\n- ts-node: ^10.9.1\n- typescript: ^4.9.5",
		"isFolder": true,
		"updated": "2023-03-27T19:26:52.024Z",
		"sidebar_position": 1,
		"sidebar_label": "Read Me",
		"init": false,
		"postInit": false,
		"generator": "ReadMe",
		"saveToPath": ".",
		"documentation_type": "md",
		"id": "ReadMe"
	},
	{
		"name": "Behaviour",
		"path": "",
		"folderPath": "./",
		"fileContent": "",
		"documentation": "# Behavior\n\nCode-narrator is an application that helps generate documentation for your project in a markdown format. It is installed using `npm i code-narrator` and can be executed either by running `npm run start` or using the command-line interface (CLI).\n\nWhen the application starts, it loads the configuration and cached documentation. It then goes through the project code, reading the file and folder structure. If a file or folder does not exist in the cache or has changed since it was last cached, code-narrator sends the code to GPT and requests documentation in a markdown format. Once the documentation is received, it is written to the cache. When all files and folders have been parsed, code-narrator creates the documentation from the cache.\n\nThere are a few rules to follow when using code-narrator:\n\n1. Write a description of the project in the project file (e.g., `package.json`).\n2. If GPT generates incorrect documentation, the code is probably not clear for humans either. Try adjusting the code or adding a one-line comment to make the code clearer.\n3. You can use `:::tip` or `:::danger` in your comments in your code files.\n\nWhen the application finishes generating the documentation, it will display a \"Done generating documents\" message in the console.",
		"isFolder": true,
		"updated": "2023-03-27T19:27:26.751Z",
		"sidebar_position": 2,
		"sidebar_label": "Behaviour",
		"init": false,
		"postInit": false,
		"generator": "Behaviour",
		"saveToPath": ".",
		"documentation_type": "md",
		"id": "Behaviour"
	},
	{
		"name": "Prerequisites",
		"path": "",
		"folderPath": "./",
		"fileContent": "",
		"documentation": "Prerequisites for the \"code-narrator\" project:\n\n:::info\n- Knowledge of JavaScript and TypeScript\n- Familiarity with Node.js and npm\n:::\n\nRequired software and tools:\n\n1. Node.js (version >18)\n2. npm (for package management)\n\nRequired dependencies:\n\n1. asynckit (version ^0.4.0)\n2. axios (version ^0.26.1)\n3. combined-stream (version ^1.0.8)\n4. delayed-stream (version ^1.0.0)\n5. dotenv (version ^16.0.3)\n6. extract-json-from-string (version ^1.0.1)\n7. follow-redirects (version ^1.15.2)\n8. form-data (version ^4.0.0)\n9. liquidjs (version ^10.7.0)\n10. mime-db (version ^1.52.0)\n11. mime-types (version ^2.1.35)\n12. openai (version ^3.1.0)\n\nRequired devDependencies:\n\n1. @babel/preset-typescript (version ^7.21.0)\n2. @jest/globals (version ^29.5.0)\n3. @types/jest (version ^29.4.0)\n4. @types/node (version ^18.11.19)\n5. jest (version ^29.4.2)\n6. ts-jest (version ^29.0.5)\n7. ts-node (version ^10.9.1)\n8. typescript (version ^4.9.5)",
		"isFolder": true,
		"updated": "2023-03-27T19:57:35.805Z",
		"sidebar_position": 4,
		"sidebar_label": "Prerequisites",
		"init": false,
		"postInit": false,
		"generator": "Prerequisites",
		"saveToPath": ".",
		"documentation_type": "md",
		"id": "Prerequisites"
	},
	{
		"name": "Usage",
		"path": "",
		"folderPath": "./",
		"fileContent": "",
		"documentation": "To use the library in your own project, follow these steps:\n\n1. Install the package:\n\n```bash\nnpm i code-narrator -D\n```\n\n2. Create a configuration file named `code-narrator.config.ts` in your project root directory and paste the following content:\n\n```typescript\nimport ConfigurationBuilder from \"./src/documentation/plugins/builders/Configuration/ConfigurationBuilder\";\nimport FilesBuilder from \"./src/documentation/plugins/builders/Files/FilesBuilder\";\nimport FoldersBuilder from \"./src/documentation/plugins/builders/Folders/FoldersBuilder\";\nimport ReadMeBuilder from \"./src/documentation/plugins/builders/ReadMe/ReadMeBuilder\";\nimport BehaviourBuilder from \"./src/documentation/plugins/builders/Behaviour/BehaviourBuilder\";\nimport DocusaurusGenerator from \"./src/documentation/plugins/generators/Docusaurus/DocusaurusGenerator\";\nimport PrerequisitesBuilder from \"./src/documentation/plugins/builders/Prerequisites/PrerequisitesBuilder\";\nimport UsageBuilder from \"./src/documentation/plugins/builders/Usage/UsageBuilder\";\n\nexport default {\n    // ... (copy the content from the provided code-narrator.config.ts file)\n};\n```\n\n3. Update your `package.json` file to include the following scripts:\n\n```json\n\"scripts\": {\n  \"test\": \"echo \\\\\\\"Error: no __tests__ specified\\\\\\\" && exit 1\",\n  \"start\": \"npx ts-node .\\\\src\\\\App.ts\",\n  \"start:comment\": \"To start the application run 'npm run start'\"\n},\n```\n\n4. Run the application:\n\n```bash\nnpm run start\n```\n\n:::note\nThe library will generate documentation in the specified format (e.g., Markdown) based on your configuration settings.\n:::\n\n:::info\nMake sure to commit the `.code-narrator/cache.json` file to your Git repository to keep track of the cache.\n:::",
		"isFolder": true,
		"updated": "2023-03-27T19:58:19.250Z",
		"sidebar_position": 5,
		"sidebar_label": "Usage",
		"init": false,
		"postInit": false,
		"generator": "Usage",
		"saveToPath": ".",
		"documentation_type": "md",
		"id": "Usage"
	},
	{
		"name": "SuggestionBuilderTest.ts",
		"path": "__tests__\\logic\\SuggestionBuilderTest.ts",
		"folderPath": "__tests__\\logic",
		"fileContent": "import DocumentationBuilder from \"../../src/logic/DocumentationBuilder\";\r\n\r\ndescribe(\"Test SuggestionBuilder\", () => {\r\n\r\n\r\n    it(\"Should create cn.md file with the project description, it uses package.json to get the project name, how to install, and run the module\", async () => {\r\n        let builder = new DocumentationBuilder();\r\n        builder.createGetStarted();\r\n    })\r\n\r\n})",
		"documentation": "# SuggestionBuilderTest.ts\n\nThis file contains test cases for the `SuggestionBuilder` class, which is responsible for generating documentation based on the project's `package.json` file. The test cases ensure that the class can create a `cn.md` file with the correct project description, installation, and usage instructions.\n\n## Table of Contents\n\n- [Examples](#examples)\n- [Methods](#methods)\n  - [createGetStarted](#creategetstarted)\n- [Technical Concepts](#technical-concepts)\n\n## Examples\n\nHere are some examples of how to use the `SuggestionBuilder` class:\n\n```typescript\nimport DocumentationBuilder from \"../../src/logic/DocumentationBuilder\";\n\n// Create a new instance of the DocumentationBuilder class\nlet builder = new DocumentationBuilder();\n\n// Generate the cn.md file with the project description, installation, and usage instructions\nbuilder.createGetStarted();\n```\n\n## Methods\n\n### createGetStarted\n\n```typescript\ncreateGetStarted(): void\n```\n\nThis method generates a `cn.md` file with the project description, installation, and usage instructions. It uses the `package.json` file to get the project name, installation, and usage instructions.\n\n#### Parameters\n\nThis method does not have any parameters.\n\n## Technical Concepts\n\n### JSON\n\nJSON (JavaScript Object Notation) is a lightweight data interchange format that is easy for humans to read and write and easy for machines to parse and generate. JSON is a text format that is completely language-independent but uses conventions that are familiar to programmers of the C family of languages, including C, C++, C#, Java, JavaScript, Perl, Python, and many others. In this file, JSON is used to read the `package.json` file and extract the necessary information for generating the documentation.",
		"isFolder": false,
		"updated": "2023-03-28T10:35:19.527Z",
		"sidebar_position": 0,
		"sidebar_label": "SuggestionBuilderTest.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "__tests__\\logic",
		"documentation_type": "md",
		"id": "__tests__\\logic\\SuggestionBuilderTest.ts"
	},
	{
		"name": "OpenAIRepositoryTest.ts",
		"path": "__tests__\\repositories\\OpenAIRepositoryTest.ts",
		"folderPath": "__tests__\\repositories",
		"fileContent": "import OpenAIRepository from \"../../src/repositories/OpenAIRepository\";\r\nimport {CreateCompletionResponse, OpenAIApi} from \"openai\";\r\nimport {AxiosResponse} from \"axios\";\r\nimport {describe, expect, test} from '@jest/globals';\r\nimport ConfigHelper from \"../../src/utils/ConfigHelper\";\r\n\r\ndescribe('Test OpenAIRepository', () => {\r\n\r\n    it('should test queryQuestions', async () => {\r\n        let questions = ['How are you?', 'What are you doing?']\r\n\r\n        let spyOpenAIApi = jest.spyOn(OpenAIApi.prototype, 'createCompletion')\r\n            .mockImplementation(() => {\r\n                return {data : {\r\n                    choices : ['hello man', 'yes man']\r\n                    }} as any\r\n            })\r\n\r\n        let openAIRepository = new OpenAIRepository();\r\n        let answers = await openAIRepository.queryQuestions(questions)\r\n\r\n        expect(spyOpenAIApi).toBeCalledTimes(1);\r\n    })\r\n\r\n\r\n})",
		"documentation": "# OpenAIRepositoryTest.ts\n\nThis documentation provides an in-depth explanation of the `OpenAIRepositoryTest.ts` file, which contains tests for the `OpenAIRepository` class. The `OpenAIRepository` class is responsible for interacting with the OpenAI API to query questions and receive answers. This file uses Jest, a JavaScript testing framework, to test the functionality of the `OpenAIRepository` class.\n\n## Table of Contents\n\n- [Test Suite: OpenAIRepository](#test-suite-openairepository)\n  - [Test: queryQuestions](#test-queryquestions)\n    - [Mocking OpenAIApi](#mocking-openaiapi)\n    - [Testing the Functionality](#testing-the-functionality)\n\n## Test Suite: OpenAIRepository\n\nThe test suite for the `OpenAIRepository` class is defined using the `describe` function from Jest. This function groups the tests related to the `OpenAIRepository` class.\n\n```javascript\ndescribe('Test OpenAIRepository', () => {\n  // Test cases go here\n});\n```\n\n### Test: queryQuestions\n\nThis test case checks the functionality of the `queryQuestions` method in the `OpenAIRepository` class. The `queryQuestions` method takes an array of questions as input and returns an array of answers from the OpenAI API.\n\n```javascript\nit('should test queryQuestions', async () => {\n  // Test implementation goes here\n});\n```\n\n#### Mocking OpenAIApi\n\nTo test the `queryQuestions` method, we need to mock the `createCompletion` method of the `OpenAIApi` class. This is done using Jest's `spyOn` function, which allows us to replace the original implementation with a custom one. In this case, we return a mock response containing an array of choices.\n\n```javascript\nlet spyOpenAIApi = jest.spyOn(OpenAIApi.prototype, 'createCompletion')\n  .mockImplementation(() => {\n    return {data : {\n      choices : ['hello man', 'yes man']\n      }} as any\n  });\n```\n\n#### Testing the Functionality\n\nAfter mocking the `createCompletion` method, we can create a new instance of the `OpenAIRepository` class and call the `queryQuestions` method with a sample array of questions. We then check if the `createCompletion` method was called once and if the returned answers match the expected output.\n\n```javascript\nlet openAIRepository = new OpenAIRepository();\nlet answers = await openAIRepository.queryQuestions(questions);\n\nexpect(spyOpenAIApi).toBeCalledTimes(1);\n```\n\nIn this test case, we verify that the `queryQuestions` method in the `OpenAIRepository` class works as expected by interacting with the mocked OpenAI API and returning the correct answers.",
		"isFolder": false,
		"updated": "2023-03-28T10:36:29.144Z",
		"sidebar_position": 0,
		"sidebar_label": "OpenAIRepositoryTest.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "__tests__\\repositories",
		"documentation_type": "md",
		"id": "__tests__\\repositories\\OpenAIRepositoryTest.ts"
	},
	{
		"name": "logic",
		"path": "__tests__\\logic",
		"folderPath": "__tests__\\logic",
		"fileContent": "",
		"documentation": "# logic\n\nThis folder is responsible for handling the logic of the system. It contains files and folders that are essential for the proper functioning of the system. The content of this folder is described in the following sections.\n\n## SuggestionBuilderTest.ts\n\n[SuggestionBuilderTest.ts](SuggestionBuilderTest.ts) contains test cases for the `SuggestionBuilder` class, which is responsible for generating documentation based on the project's `package.json` file. The test cases ensure that the class can create a `cn.md` file with the correct project description, installation, and usage instructions.\n\n### Table of Contents\n\n- [SuggestionBuilderTest.ts](#suggestionbuildertestts)\n\n---\n\n[Repository](https://github.com/ingig/code-narrator/__tests__/logic)",
		"isFolder": true,
		"updated": "2023-03-28T10:36:51.115Z",
		"sidebar_position": 30,
		"sidebar_label": "Logic",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "__tests__",
		"documentation_type": "md",
		"id": "__tests__\\logic"
	},
	{
		"name": "repositories",
		"path": "__tests__\\repositories",
		"folderPath": "__tests__\\repositories",
		"fileContent": "",
		"documentation": "# Repositories\n\nThis folder contains various repositories that are responsible for handling different aspects of the system. Each repository has its own set of responsibilities and interacts with different APIs or services.\n\n## Table of Contents\n\n- [OpenAIRepositoryTest.ts](#openairepositorytestts)\n\n### OpenAIRepositoryTest.ts\n\nThis documentation provides an in-depth explanation of the `OpenAIRepositoryTest.ts` file, which contains tests for the `OpenAIRepository` class. The `OpenAIRepository` class is responsible for interacting with the OpenAI API to query questions and receive answers. This file uses Jest, a JavaScript testing framework, to test the functionality of the `OpenAIRepository` class.\n\n[OpenAIRepositoryTest.ts Documentation](OpenAIRepositoryTest.ts)\n\n---\n\n[Back to Repository](https://github.com/ingig/code-narrator/__tests__/repositories)",
		"isFolder": true,
		"updated": "2023-03-28T10:37:12.143Z",
		"sidebar_position": 31,
		"sidebar_label": "Repositories",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "__tests__",
		"documentation_type": "md",
		"id": "__tests__\\repositories"
	},
	{
		"name": "BaseBuilder.ts",
		"path": "src\\documentation\\plugins\\builders\\BaseBuilder.ts",
		"folderPath": "src\\documentation\\plugins\\builders",
		"fileContent": "import OpenAIRepository from \"../../../repositories/OpenAIRepository\";\r\nimport Document from \"../../Document\";\r\nimport DocumentationCache from \"../../DocumentationCache\";\r\nimport {Liquid} from \"liquidjs\";\r\nimport path from \"path\";\r\nimport ConfigHelper from \"../../../utils/ConfigHelper\";\r\nimport fs from \"fs\";\r\nimport {GenerateOptions} from \"../GenerateOptions\";\r\n\r\n/*\r\nThis is the Base class for Builder plugins. Builder plugins are used to generate questions for GPT\r\nand then parse the response and loading it into the document object that is later cached.\r\n */\r\nexport default abstract class BaseBuilder {\r\n    openAIRepository: OpenAIRepository;\r\n    generator: string;\r\n    project : any;\r\n\r\n    protected constructor(generator: string, project : any) {\r\n        this.openAIRepository = new OpenAIRepository();\r\n        this.generator = generator;\r\n        this.project = project;\r\n    }\r\n\r\n    abstract generate() : any;\r\n\r\n    abstract render(document: Document): Promise<string>;\r\n\r\n    public async getAnswer(name: string, args: any, template = 'template') : Promise<[string, string]> {\r\n        const engine = new Liquid({\r\n            extname: '.liquid'\r\n        });\r\n        if (!args.projectName) {\r\n            args.projectName = this.project.projectName;\r\n        }\r\n        if (!args.fileName) {\r\n            args.fileName = name\r\n        }\r\n\r\n        let project_path = ConfigHelper.get('project_path');\r\n        let pathToTemplate = path.join(project_path, `src/documentation/plugins/builders/${this.generator}/${template}`);\r\n        let question = await engine.renderFile(pathToTemplate, args)\r\n        console.log(`Asking about ${name} using template ${template}`)\r\n        let response = await this.openAIRepository.queryQuestions([question]);\r\n        if (!response) return ['', question];\r\n        console.log(`Received answer for ${name}`)\r\n        return [response[0].message!.content, question]\r\n    }\r\n\r\n    public async generateDocumentation({\r\n                                           id,\r\n                                           args,\r\n                                           template = 'gpt_question',\r\n                                           name,\r\n                                           pathToFile,\r\n                                           folderPath,\r\n                                           sidebarPosition,\r\n                                           sidebarLabel, saveToPath, data\r\n                                       }: GenerateOptions) {\r\n\r\n        let [answer, question] = await this.getAnswer(name, args, template)\r\n        let document = new Document(name, pathToFile, folderPath, new Date(), sidebarPosition, sidebarLabel)\r\n        document.documentation = answer;\r\n        document.question = question;\r\n        document.documentation_type = ConfigHelper.DocumentationType;\r\n        document.generator = this.generator;\r\n        document.saveToPath = (saveToPath) ? saveToPath : path.dirname(pathToFile);\r\n        document.data = data;\r\n        return document;\r\n    }\r\n\r\n    /*\r\n        This is where the magic happens. Retrieve the question from liquid file, input the args, ask GPT, create the document and store it in cache\r\n    */\r\n    public async generateDocumentationAndCache({\r\n                                                   id,\r\n                                                   args,\r\n                                                   template = 'gpt_question',\r\n                                                   name,\r\n                                                   pathToFile,\r\n                                                   folderPath,\r\n                                                   sidebarPosition,\r\n                                                   sidebarLabel,\r\n                                                   saveToPath,\r\n                                                   data\r\n                                               }: GenerateOptions) {\r\n        let document = await this.generateDocumentation({\r\n            id, args,\r\n            template,\r\n            name,\r\n            pathToFile,\r\n            folderPath,\r\n            sidebarPosition,\r\n            sidebarLabel, saveToPath, data\r\n        })\r\n        DocumentationCache.set(document);\r\n    }\r\n\r\n    public hasChanged(document?: Document) {\r\n        if (!document) return true;\r\n\r\n        let project_path = ConfigHelper.get('project_path')\r\n        let filePath = path.join(project_path, document.path);\r\n        if (!fs.existsSync(filePath)) {\r\n            DocumentationCache.remove(document)\r\n            return false;\r\n        }\r\n        if (document.documentation_type && document.documentation_type != ConfigHelper.DocumentationType) return true;\r\n\r\n        let stats = fs.statSync(filePath);\r\n        return (stats.mtime.getTime() >= new Date(document.updated.toString()).getTime());\r\n    }\r\n}",
		"documentation": "# BaseBuilder.ts\n\nBaseBuilder.ts is a TypeScript file that defines an abstract class `BaseBuilder` for creating Builder plugins. These plugins are used to generate questions for GPT, parse the response, and load it into a `Document` object that is later cached.\n\n## Class: BaseBuilder\n\nThe `BaseBuilder` class is an abstract class that provides a base structure for creating Builder plugins. It has the following properties and methods:\n\n### Properties\n\n- `openAIRepository`: An instance of the `OpenAIRepository` class.\n- `generator`: A string representing the generator used for the Builder plugin.\n- `project`: An object representing the project.\n\n### Constructor\n\nThe constructor takes two parameters:\n\n- `generator` (string): The generator used for the Builder plugin.\n- `project` (any): The project object.\n\n### Methods\n\n#### generate()\n\nAn abstract method that should be implemented by the derived class.\n\n#### render(document: Document): Promise<string>\n\nAn abstract method that should be implemented by the derived class. It takes a `Document` object as a parameter and returns a Promise that resolves to a string.\n\n#### getAnswer(name: string, args: any, template = 'template'): Promise<[string, string]>\n\nThis method takes three parameters:\n\n- `name` (string): The name of the file.\n- `args` (any): The arguments for the question.\n- `template` (string, optional, default: 'template'): The template to use for generating the question.\n\nIt returns a Promise that resolves to a tuple containing the answer and the question.\n\n#### generateDocumentation(options: GenerateOptions)\n\nThis method takes an object of type `GenerateOptions` as a parameter and returns a `Document` object. It generates the documentation by asking GPT a question and creating a new `Document` object with the answer.\n\n#### generateDocumentationAndCache(options: GenerateOptions)\n\nThis method takes an object of type `GenerateOptions` as a parameter and generates the documentation using the `generateDocumentation` method. It then stores the generated `Document` object in the cache using the `DocumentationCache.set()` method.\n\n#### hasChanged(document?: Document): boolean\n\nThis method takes an optional `Document` object as a parameter and returns a boolean value. It checks if the document has changed by comparing the file modification time with the document's updated time. If the document has changed, it returns `true`, otherwise, it returns `false`.\n\n## Example Usage\n\nTo create a custom Builder plugin, you can extend the `BaseBuilder` class and implement the `generate()` and `render()` methods. Here's an example:\n\n```typescript\nimport BaseBuilder from \"./BaseBuilder\";\nimport Document from \"../../Document\";\n\nclass CustomBuilder extends BaseBuilder {\n  constructor(generator: string, project: any) {\n    super(generator, project);\n  }\n\n  generate() {\n    // Implement the generate method\n  }\n\n  async render(document: Document): Promise<string> {\n    // Implement the render method\n  }\n}\n```\n\nThen, you can use the `CustomBuilder` class to generate and cache documentation:\n\n```typescript\nconst customBuilder = new CustomBuilder(\"customGenerator\", project);\ncustomBuilder.generateDocumentationAndCache(options);\n```",
		"isFolder": false,
		"updated": "2023-03-28T13:34:01.386Z",
		"sidebar_position": 0,
		"sidebar_label": "BaseBuilder.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"BaseBuilder.ts\"\r\nThe file name is: BaseBuilder.ts\r\n\r\nIf this is a code file, then\n- Write detailed description for the code that will follow. \n- Give multiple examples of how to use this class before listing each method\n- Create a description for each method in the code. \n- List out the parameters in methods (only if there are any) and write a description for each parameter.\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\n- Divide the document into sections with clear headings and subheadings.\nElse \n- Write detailed description about the file content will follow.\n                    \r\n\r\nThis is the content of the file:\r\n###\r\nimport OpenAIRepository from \"../../../repositories/OpenAIRepository\";\r\nimport Document from \"../../Document\";\r\nimport DocumentationCache from \"../../DocumentationCache\";\r\nimport {Liquid} from \"liquidjs\";\r\nimport path from \"path\";\r\nimport ConfigHelper from \"../../../utils/ConfigHelper\";\r\nimport fs from \"fs\";\r\nimport {GenerateOptions} from \"../GenerateOptions\";\r\n\r\n/*\r\nThis is the Base class for Builder plugins. Builder plugins are used to generate questions for GPT\r\nand then parse the response and loading it into the document object that is later cached.\r\n */\r\nexport default abstract class BaseBuilder {\r\n    openAIRepository: OpenAIRepository;\r\n    generator: string;\r\n    project : any;\r\n\r\n    protected constructor(generator: string, project : any) {\r\n        this.openAIRepository = new OpenAIRepository();\r\n        this.generator = generator;\r\n        this.project = project;\r\n    }\r\n\r\n    abstract generate() : any;\r\n\r\n    abstract render(document: Document): Promise<string>;\r\n\r\n    public async getAnswer(name: string, args: any, template = 'template') : Promise<[string, string]> {\r\n        const engine = new Liquid({\r\n            extname: '.liquid'\r\n        });\r\n        if (!args.projectName) {\r\n            args.projectName = this.project.projectName;\r\n        }\r\n        if (!args.fileName) {\r\n            args.fileName = name\r\n        }\r\n\r\n        let project_path = ConfigHelper.get('project_path');\r\n        let pathToTemplate = path.join(project_path, `src/documentation/plugins/builders/${this.generator}/${template}`);\r\n        let question = await engine.renderFile(pathToTemplate, args)\r\n        console.log(`Asking about ${name} using template ${template}`)\r\n        let response = await this.openAIRepository.queryQuestions([question]);\r\n        if (!response) return ['', question];\r\n        console.log(`Received answer for ${name}`)\r\n        return [response[0].message!.content, question]\r\n    }\r\n\r\n    public async generateDocumentation({\r\n                                           id,\r\n                                           args,\r\n                                           template = 'gpt_question',\r\n                                           name,\r\n                                           pathToFile,\r\n                                           folderPath,\r\n                                           sidebarPosition,\r\n                                           sidebarLabel, saveToPath, data\r\n                                       }: GenerateOptions) {\r\n\r\n        let [answer, question] = await this.getAnswer(name, args, template)\r\n        let document = new Document(name, pathToFile, folderPath, new Date(), sidebarPosition, sidebarLabel)\r\n        document.documentation = answer;\r\n        document.question = question;\r\n        document.documentation_type = ConfigHelper.DocumentationType;\r\n        document.generator = this.generator;\r\n        document.saveToPath = (saveToPath) ? saveToPath : path.dirname(pathToFile);\r\n        document.data = data;\r\n        return document;\r\n    }\r\n\r\n    /*\r\n        This is where the magic happens. Retrieve the question from liquid file, input the args, ask GPT, create the document and store it in cache\r\n    */\r\n    public async generateDocumentationAndCache({\r\n                                                   id,\r\n                                                   args,\r\n                                                   template = 'gpt_question',\r\n                                                   name,\r\n                                                   pathToFile,\r\n                                                   folderPath,\r\n                                                   sidebarPosition,\r\n                                                   sidebarLabel,\r\n                                                   saveToPath,\r\n                                                   data\r\n                                               }: GenerateOptions) {\r\n        let document = await this.generateDocumentation({\r\n            id, args,\r\n            template,\r\n            name,\r\n            pathToFile,\r\n            folderPath,\r\n            sidebarPosition,\r\n            sidebarLabel, saveToPath, data\r\n        })\r\n        DocumentationCache.set(document);\r\n    }\r\n\r\n    public hasChanged(document?: Document) {\r\n        if (!document) return true;\r\n\r\n        let project_path = ConfigHelper.get('project_path')\r\n        let filePath = path.join(project_path, document.path);\r\n        if (!fs.existsSync(filePath)) {\r\n            DocumentationCache.remove(document)\r\n            return false;\r\n        }\r\n        if (document.documentation_type && document.documentation_type != ConfigHelper.DocumentationType) return true;\r\n\r\n        let stats = fs.statSync(filePath);\r\n        return (stats.mtime.getTime() >= new Date(document.updated.toString()).getTime());\r\n    }\r\n}\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\BaseBuilder.ts"
	},
	null,
	null,
	null,
	{
		"name": "ConfigurationBuilder.ts",
		"path": "src\\documentation\\plugins\\builders\\Configuration\\ConfigurationBuilder.ts",
		"folderPath": "src\\documentation\\plugins\\builders\\Configuration",
		"fileContent": "import Document from \"../../../Document\";\r\nimport FolderStructure from \"../../../../utils/FolderStructure\";\r\nimport ConfigHelper from \"../../../../utils/ConfigHelper\";\r\nimport Helper from \"../../../../utils/Helper\";\r\nimport FileStructure from \"../../../../utils/FileStructure\";\r\nimport DocumentationCache from \"../../../DocumentationCache\";\r\nimport BaseBuilder from \"../BaseBuilder\";\r\nimport path from \"path\";\r\n\r\nexport default class ConfigurationBuilder extends BaseBuilder {\r\n\r\n    configFiles: string[] = []\r\n    appSpecificConfigFiles: string[] = []\r\n    updateSummary = false;\r\n\r\n    constructor(project : any) {\r\n        super('Configuration', project);\r\n    }\r\n\r\n\r\n    public async generate() {\r\n        await this.prepareSummary();\r\n        await this.generateAppConfigFiles();\r\n        await this.generateGeneralConfigFiles();\r\n        await this.generateSummary();\r\n    }\r\n\r\n    private async prepareSummary() {\r\n        let document = DocumentationCache.get('Configuration');\r\n        if (document) {\r\n            if (document.data) {\r\n                if (document.data.appSpecificConfigFiles) this.appSpecificConfigFiles = document.data.appSpecificConfigFiles;\r\n                if (document.data.configFiles) this.configFiles = document.data.configFiles;\r\n            }\r\n        }\r\n\r\n        if (document && !this.haveConfigFilesChanged()) {\r\n            return;\r\n        }\r\n        this.updateSummary = true;\r\n        let appName = ConfigHelper.get('name');\r\n        let listOfFilesAndFolders = '';\r\n\r\n        let files = FolderStructure.getFiles(ConfigHelper.get('project_path'));\r\n\r\n        let configPath = path.join(ConfigHelper.get('project_path'), 'config');\r\n        if (FolderStructure.exists(configPath)) {\r\n            let configFiles = FolderStructure.getFiles(configPath);\r\n            configFiles.forEach(configFile => {\r\n                files.push(configFile);\r\n            })\r\n        }\r\n        files.forEach(file => {\r\n            if (file.path.indexOf('/config') != -1) {\r\n                listOfFilesAndFolders += 'config/' + file.name + '\\n';\r\n            } else {\r\n                listOfFilesAndFolders += file.name + '\\n'\r\n            }\r\n        })\r\n\r\n        let [answer, question] = await super.getAnswer('Configuration', {appName, listOfFilesAndFolders}, 'what_are_config_files');\r\n        let jsons = Helper.getJsons(answer)\r\n        if (jsons.length > 0) {\r\n            let fileResults = jsons[0];\r\n            this.appSpecificConfigFiles = [];\r\n            this.configFiles = [];\r\n\r\n            fileResults.forEach((file: any) => {\r\n                if (file.isAppSpecific) {\r\n                    this.appSpecificConfigFiles.push(file.path);\r\n                } else if (file.isConfig) {\r\n                    this.configFiles.push(file.path)\r\n                }\r\n            })\r\n        }\r\n    }\r\n    private async generateSummary() {\r\n        if (!this.updateSummary) {\r\n            return;\r\n        }\r\n\r\n        let data: any = {\r\n            appSpecificConfigFiles: this.appSpecificConfigFiles,\r\n            configFiles: this.configFiles\r\n        }\r\n\r\n        let appSpecificConfigContent = '';\r\n        for (let i = 0; i < this.appSpecificConfigFiles.length; i++) {\r\n            appSpecificConfigContent += `--- Start ${this.appSpecificConfigFiles[0]} ---\r\n            ${FileStructure.getContent(this.appSpecificConfigFiles[0])}\r\n            --- End ${this.appSpecificConfigFiles[0]} ---\r\n            `\r\n        }\r\n\r\n        let args = {\r\n            appSpecificConfigFiles: this.appSpecificConfigFiles.join('\\n'),\r\n            appSpecificConfigContent,\r\n            configFiles: this.configFiles.join('\\n')\r\n        }\r\n        await super.generateDocumentationAndCache({\r\n                args: args, name: 'Configuration', saveToPath:'./Configuration', pathToFile: './Configuration', folderPath: './Configuration', sidebarPosition: 3, data: data\r\n            }\r\n\r\n        )\r\n    }\r\n\r\n    private haveConfigFilesChanged() {\r\n        let needsUpdate = false;\r\n        for (let i=0;i<this.appSpecificConfigFiles.length;i++) {\r\n            let configDoc = DocumentationCache.get(this.appSpecificConfigFiles[i]);\r\n            if (this.hasChanged(configDoc)) {\r\n                needsUpdate = true;\r\n                i = this.appSpecificConfigFiles.length;\r\n            }\r\n        }\r\n\r\n        for (let i=0;!needsUpdate && i<this.configFiles.length;i++) {\r\n            let configDoc = DocumentationCache.get(this.configFiles[i]);\r\n            if (this.hasChanged(configDoc)) {\r\n                needsUpdate = true;\r\n                i = this.configFiles.length;\r\n            }\r\n        }\r\n        return needsUpdate;\r\n    }\r\n\r\n    private async generateAppConfigFiles() {\r\n        for (let i = 0; i < this.appSpecificConfigFiles.length; i++) {\r\n            let document = DocumentationCache.get(this.appSpecificConfigFiles[i])\r\n            if (!this.hasChanged(document)) {\r\n                continue;\r\n            }\r\n            this.updateSummary = true;\r\n            let content = FileStructure.getContent(this.appSpecificConfigFiles[i])\r\n            if (content == '') continue;\r\n\r\n            let args = {configFile: content, fileName : this.appSpecificConfigFiles[i]}\r\n            await super.generateDocumentationAndCache({\r\n                    args: args,\r\n                    template: 'app_config',\r\n                    name: this.appSpecificConfigFiles[i],\r\n                    pathToFile: './' + this.appSpecificConfigFiles[i],\r\n                    folderPath: './',\r\n                    sidebarPosition: i,\r\n                    saveToPath: './Configuration/'\r\n                }\r\n            )\r\n        }\r\n    }\r\n\r\n    private async generateGeneralConfigFiles() {\r\n        for (let i = 0; i < this.configFiles.length; i++) {\r\n            let document = DocumentationCache.get(this.configFiles[i])\r\n            if (!this.hasChanged(document)) {\r\n                continue;\r\n            }\r\n            this.updateSummary = true;\r\n            let content = FileStructure.getContent(this.configFiles[i])\r\n            let args = {configFile: content}\r\n            await super.generateDocumentationAndCache({\r\n                    args: args,\r\n                    template: 'general_config',\r\n                    name: this.configFiles[i], pathToFile: './' + this.configFiles[i], folderPath: './', sidebarPosition: i,\r\n                    saveToPath: './Configuration/'\r\n                }\r\n            )\r\n        }\r\n    }\r\n\r\n    public async render(document: Document): Promise<string> {\r\n        return document.documentation;\r\n    }\r\n\r\n\r\n\r\n}",
		"documentation": "# ConfigurationBuilder.ts\n\nThe `ConfigurationBuilder.ts` file is a TypeScript class that is responsible for generating documentation for configuration files in a project. It extends the `BaseBuilder` class and provides methods to generate documentation for both app-specific and general configuration files. The class also handles caching and updating the documentation when changes are detected in the configuration files.\n\n## Table of Contents\n\n- [Class: ConfigurationBuilder](#class-configurationbuilder)\n  - [Constructor](#constructor)\n  - [Methods](#methods)\n    - [generate](#generate)\n    - [prepareSummary](#preparesummary)\n    - [generateSummary](#generatesummary)\n    - [haveConfigFilesChanged](#haveconfigfileschanged)\n    - [generateAppConfigFiles](#generateappconfigfiles)\n    - [generateGeneralConfigFiles](#generategeneralconfigfiles)\n    - [render](#render)\n\n## Class: ConfigurationBuilder\n\n### Constructor\n\nThe constructor takes a single parameter:\n\n- `project`: The project object for which the documentation is being generated.\n\n### Methods\n\n#### generate\n\nThis async method generates the documentation for the configuration files. It calls the following methods in sequence:\n\n1. `prepareSummary`\n2. `generateAppConfigFiles`\n3. `generateGeneralConfigFiles`\n4. `generateSummary`\n\n#### prepareSummary\n\nThis private async method prepares the summary of the configuration files by fetching the existing documentation from the cache and checking if any changes have been made to the configuration files. If changes are detected, it sets the `updateSummary` flag to `true`.\n\n#### generateSummary\n\nThis private async method generates the summary of the configuration files if the `updateSummary` flag is set to `true`. It creates the documentation content for app-specific and general configuration files and saves it to the cache.\n\n#### haveConfigFilesChanged\n\nThis private method checks if any changes have been made to the app-specific or general configuration files by comparing the cached documentation with the current file content. It returns `true` if changes are detected, otherwise `false`.\n\n#### generateAppConfigFiles\n\nThis private async method generates the documentation for app-specific configuration files. It iterates through the list of app-specific configuration files, checks if any changes have been made, and generates the documentation using the `generateDocumentationAndCache` method from the `BaseBuilder` class.\n\n#### generateGeneralConfigFiles\n\nThis private async method generates the documentation for general configuration files. It iterates through the list of general configuration files, checks if any changes have been made, and generates the documentation using the `generateDocumentationAndCache` method from the `BaseBuilder` class.\n\n#### render\n\nThis async method takes a `Document` object as a parameter and returns the documentation content as a string.",
		"isFolder": false,
		"updated": "2023-03-28T13:08:15.534Z",
		"sidebar_position": 0,
		"sidebar_label": "ConfigurationBuilder.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Configuration",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"ConfigurationBuilder.ts\"\r\n\r\n###\r\nIf this is a code file, then\n- Write detailed description for the code that will follow. \n- Give multiple examples of how to use this class before listing each method\n- Create a description for each method in the code. \n- List out the parameters in methods (only if there are any) and write a description for each parameter.\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\n- Divide the document into sections with clear headings and subheadings.\nElse \n- Write detailed description about the file content will follow.\n                    \r\n###\r\n\r\nThis is the content of the file:\r\n###\r\nimport Document from \"../../../Document\";\r\nimport FolderStructure from \"../../../../utils/FolderStructure\";\r\nimport ConfigHelper from \"../../../../utils/ConfigHelper\";\r\nimport Helper from \"../../../../utils/Helper\";\r\nimport FileStructure from \"../../../../utils/FileStructure\";\r\nimport DocumentationCache from \"../../../DocumentationCache\";\r\nimport BaseBuilder from \"../BaseBuilder\";\r\nimport path from \"path\";\r\n\r\nexport default class ConfigurationBuilder extends BaseBuilder {\r\n\r\n    configFiles: string[] = []\r\n    appSpecificConfigFiles: string[] = []\r\n    updateSummary = false;\r\n\r\n    constructor(project : any) {\r\n        super('Configuration', project);\r\n    }\r\n\r\n\r\n    public async generate() {\r\n        await this.prepareSummary();\r\n        await this.generateAppConfigFiles();\r\n        await this.generateGeneralConfigFiles();\r\n        await this.generateSummary();\r\n    }\r\n\r\n    private async prepareSummary() {\r\n        let document = DocumentationCache.get('Configuration');\r\n        if (document) {\r\n            if (document.data) {\r\n                if (document.data.appSpecificConfigFiles) this.appSpecificConfigFiles = document.data.appSpecificConfigFiles;\r\n                if (document.data.configFiles) this.configFiles = document.data.configFiles;\r\n            }\r\n        }\r\n\r\n        if (document && !this.haveConfigFilesChanged()) {\r\n            return;\r\n        }\r\n        this.updateSummary = true;\r\n        let appName = ConfigHelper.get('name');\r\n        let listOfFilesAndFolders = '';\r\n\r\n        let files = FolderStructure.getFiles(ConfigHelper.get('project_path'));\r\n\r\n        let configPath = path.join(ConfigHelper.get('project_path'), 'config');\r\n        if (FolderStructure.exists(configPath)) {\r\n            let configFiles = FolderStructure.getFiles(configPath);\r\n            configFiles.forEach(configFile => {\r\n                files.push(configFile);\r\n            })\r\n        }\r\n        files.forEach(file => {\r\n            if (file.path.indexOf('/config') != -1) {\r\n                listOfFilesAndFolders += 'config/' + file.name + '\\n';\r\n            } else {\r\n                listOfFilesAndFolders += file.name + '\\n'\r\n            }\r\n        })\r\n\r\n        let [answer, question] = await super.getAnswer('Configuration', {appName, listOfFilesAndFolders}, 'what_are_config_files');\r\n        let jsons = Helper.getJsons(answer)\r\n        if (jsons.length > 0) {\r\n            let fileResults = jsons[0];\r\n            this.appSpecificConfigFiles = [];\r\n            this.configFiles = [];\r\n\r\n            fileResults.forEach((file: any) => {\r\n                if (file.isAppSpecific) {\r\n                    this.appSpecificConfigFiles.push(file.path);\r\n                } else if (file.isConfig) {\r\n                    this.configFiles.push(file.path)\r\n                }\r\n            })\r\n        }\r\n    }\r\n    private async generateSummary() {\r\n        if (!this.updateSummary) {\r\n            return;\r\n        }\r\n\r\n        let data: any = {\r\n            appSpecificConfigFiles: this.appSpecificConfigFiles,\r\n            configFiles: this.configFiles\r\n        }\r\n\r\n        let appSpecificConfigContent = '';\r\n        for (let i = 0; i < this.appSpecificConfigFiles.length; i++) {\r\n            appSpecificConfigContent += `--- Start ${this.appSpecificConfigFiles[0]} ---\r\n            ${FileStructure.getContent(this.appSpecificConfigFiles[0])}\r\n            --- End ${this.appSpecificConfigFiles[0]} ---\r\n            `\r\n        }\r\n\r\n        let args = {\r\n            appSpecificConfigFiles: this.appSpecificConfigFiles.join('\\n'),\r\n            appSpecificConfigContent,\r\n            configFiles: this.configFiles.join('\\n')\r\n        }\r\n        await super.generateDocumentationAndCache({\r\n                args: args, name: 'Configuration', saveToPath:'./Configuration', pathToFile: './Configuration', folderPath: './Configuration', sidebarPosition: 3, data: data\r\n            }\r\n\r\n        )\r\n    }\r\n\r\n    private haveConfigFilesChanged() {\r\n        let needsUpdate = false;\r\n        for (let i=0;i<this.appSpecificConfigFiles.length;i++) {\r\n            let configDoc = DocumentationCache.get(this.appSpecificConfigFiles[i]);\r\n            if (this.hasChanged(configDoc)) {\r\n                needsUpdate = true;\r\n                i = this.appSpecificConfigFiles.length;\r\n            }\r\n        }\r\n\r\n        for (let i=0;!needsUpdate && i<this.configFiles.length;i++) {\r\n            let configDoc = DocumentationCache.get(this.configFiles[i]);\r\n            if (this.hasChanged(configDoc)) {\r\n                needsUpdate = true;\r\n                i = this.configFiles.length;\r\n            }\r\n        }\r\n        return needsUpdate;\r\n    }\r\n\r\n    private async generateAppConfigFiles() {\r\n        for (let i = 0; i < this.appSpecificConfigFiles.length; i++) {\r\n            let document = DocumentationCache.get(this.appSpecificConfigFiles[i])\r\n            if (!this.hasChanged(document)) {\r\n                continue;\r\n            }\r\n            this.updateSummary = true;\r\n            let content = FileStructure.getContent(this.appSpecificConfigFiles[i])\r\n            if (content == '') continue;\r\n\r\n            let args = {configFile: content, fileName : this.appSpecificConfigFiles[i]}\r\n            await super.generateDocumentationAndCache({\r\n                    args: args,\r\n                    template: 'app_config',\r\n                    name: this.appSpecificConfigFiles[i],\r\n                    pathToFile: './' + this.appSpecificConfigFiles[i],\r\n                    folderPath: './',\r\n                    sidebarPosition: i,\r\n                    saveToPath: './Configuration/'\r\n                }\r\n            )\r\n        }\r\n    }\r\n\r\n    private async generateGeneralConfigFiles() {\r\n        for (let i = 0; i < this.configFiles.length; i++) {\r\n            let document = DocumentationCache.get(this.configFiles[i])\r\n            if (!this.hasChanged(document)) {\r\n                continue;\r\n            }\r\n            this.updateSummary = true;\r\n            let content = FileStructure.getContent(this.configFiles[i])\r\n            let args = {configFile: content}\r\n            await super.generateDocumentationAndCache({\r\n                    args: args,\r\n                    template: 'general_config',\r\n                    name: this.configFiles[i], pathToFile: './' + this.configFiles[i], folderPath: './', sidebarPosition: i,\r\n                    saveToPath: './Configuration/'\r\n                }\r\n            )\r\n        }\r\n    }\r\n\r\n    public async render(document: Document): Promise<string> {\r\n        return document.documentation;\r\n    }\r\n\r\n\r\n\r\n}\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Configuration\\ConfigurationBuilder.ts"
	},
	null,
	{
		"name": "FilesBuilder.ts",
		"path": "src\\documentation\\plugins\\builders\\Files\\FilesBuilder.ts",
		"folderPath": "src\\documentation\\plugins\\builders\\Files",
		"fileContent": "import Document from \"../../../Document\";\r\nimport FileStructure from \"../../../../utils/FileStructure\";\r\nimport FolderStructure from \"../../../../utils/FolderStructure\";\r\nimport BaseBuilder from \"../BaseBuilder\";\r\nimport DocumentationCache from \"../../../DocumentationCache\";\r\nimport ProjectStructure from \"../../../../utils/ProjectStructure\";\r\n\r\n\r\nexport default class FilesBuilder extends BaseBuilder {\r\n\r\n\r\n    constructor(project : any) {\r\n        super('Files', project);\r\n    }\r\n\r\n\r\n    public async generate() {\r\n        let structure = new ProjectStructure();\r\n        let folder = await structure.getStructure();\r\n        await this.queryForFolder(folder);\r\n    }\r\n\r\n    public async render(document: Document) {\r\n        return document.documentation;\r\n    }\r\n\r\n\r\n    public async queryForFolder(folder: FolderStructure) {\r\n        this.cleanDeletedFilesFromCache(folder);\r\n\r\n\r\n        let files = folder.files;\r\n\r\n        for (let i = 0; i < files.length; i++) {\r\n            let file = files[i];\r\n\r\n            let document = DocumentationCache.get(file.path)\r\n            if (document && document.generator != \"Files\") continue;\r\n            if (!this.hasChanged(document)) {\r\n                continue;\r\n            }\r\n            let fileName = file.name;\r\n            let fileContent = FileStructure.getContent(file.path);\r\n            let args = {fileName, fileContent}\r\n\r\n            await super.generateDocumentationAndCache({\r\n                args: args,\r\n                name: fileName,\r\n                pathToFile: file.path,\r\n                folderPath: folder.path,\r\n                sidebarPosition: i,\r\n                sidebarLabel: fileName\r\n            })\r\n        }\r\n\r\n        for (let i = 0; i < folder.folders.length; i++) {\r\n            await this.queryForFolder(folder.folders[i]);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    private cleanDeletedFilesFromCache(folder: FolderStructure) {\r\n        let cachedFiles = DocumentationCache.getByFolderPath(folder.path);\r\n        for (let i=0;i<cachedFiles.length;i++) {\r\n            if (cachedFiles[i].isFolder) continue;\r\n\r\n            let fileExists = false;\r\n            for (let b=0;b<folder.files.length;b++) {\r\n                if (cachedFiles[i].path == folder.files[b].path) {\r\n                    b = folder.files.length;\r\n                    fileExists = true;\r\n                }\r\n            }\r\n            if (!fileExists) {\r\n                console.warn(`Remove file ${cachedFiles[i].path} from cache`)\r\n                DocumentationCache.remove(cachedFiles[i]);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n}",
		"documentation": "# FilesBuilder.ts\n\n## Overview\n\nThe `FilesBuilder.ts` file is a TypeScript code file that defines a `FilesBuilder` class, which extends the `BaseBuilder` class. This class is responsible for generating and rendering documentation for files in a project structure, as well as managing the documentation cache for these files.\n\n## Usage\n\nTo use the `FilesBuilder` class, you need to import it and create a new instance by passing a `project` object to the constructor. Then, you can call the `generate()` method to generate the documentation for the files in the project structure.\n\n```typescript\nimport FilesBuilder from \"./path/to/FilesBuilder\";\n\nconst project = { /* project object */ };\nconst filesBuilder = new FilesBuilder(project);\n\nawait filesBuilder.generate();\n```\n\n## Class Methods\n\n### constructor(project: any)\n\nThe constructor initializes a new instance of the `FilesBuilder` class with the given `project` object.\n\n### async generate()\n\nThis method generates the documentation for the files in the project structure. It creates a new `ProjectStructure` instance, retrieves the folder structure, and then calls the `queryForFolder()` method for the root folder.\n\n### async render(document: Document)\n\nThis method renders the documentation for a given `document` object. It returns the `documentation` property of the `document` object.\n\n### async queryForFolder(folder: FolderStructure)\n\nThis method recursively queries the given `folder` and its subfolders for files, generating and caching the documentation for each file. It also cleans up the documentation cache for deleted files by calling the `cleanDeletedFilesFromCache()` method.\n\n### private cleanDeletedFilesFromCache(folder: FolderStructure)\n\nThis private method cleans up the documentation cache for deleted files in the given `folder`. It checks if each cached file still exists in the folder, and if not, removes it from the cache.\n\n## Technical Concepts\n\n### ProjectStructure\n\nThe `ProjectStructure` class is a utility class that represents the structure of a project, including its folders and files.\n\n### FolderStructure\n\nThe `FolderStructure` class is a utility class that represents the structure of a folder, including its subfolders and files.\n\n### FileStructure\n\nThe `FileStructure` class is a utility class that represents the structure of a file, including its content and metadata.\n\n### DocumentationCache\n\nThe `DocumentationCache` class is a utility class that manages the caching of documentation for files and folders in a project structure.",
		"isFolder": false,
		"updated": "2023-03-28T14:00:13.946Z",
		"sidebar_position": 0,
		"sidebar_label": "FilesBuilder.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Files",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"FilesBuilder.ts\"\r\nThe file name is: FilesBuilder.ts\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nimport Document from \"../../../Document\";\r\nimport FileStructure from \"../../../../utils/FileStructure\";\r\nimport FolderStructure from \"../../../../utils/FolderStructure\";\r\nimport BaseBuilder from \"../BaseBuilder\";\r\nimport DocumentationCache from \"../../../DocumentationCache\";\r\nimport ProjectStructure from \"../../../../utils/ProjectStructure\";\r\n\r\n\r\nexport default class FilesBuilder extends BaseBuilder {\r\n\r\n\r\n    constructor(project : any) {\r\n        super('Files', project);\r\n    }\r\n\r\n\r\n    public async generate() {\r\n        let structure = new ProjectStructure();\r\n        let folder = await structure.getStructure();\r\n        await this.queryForFolder(folder);\r\n    }\r\n\r\n    public async render(document: Document) {\r\n        return document.documentation;\r\n    }\r\n\r\n\r\n    public async queryForFolder(folder: FolderStructure) {\r\n        this.cleanDeletedFilesFromCache(folder);\r\n\r\n\r\n        let files = folder.files;\r\n\r\n        for (let i = 0; i < files.length; i++) {\r\n            let file = files[i];\r\n\r\n            let document = DocumentationCache.get(file.path)\r\n            if (document && document.generator != \"Files\") continue;\r\n            if (!this.hasChanged(document)) {\r\n                continue;\r\n            }\r\n            let fileName = file.name;\r\n            let fileContent = FileStructure.getContent(file.path);\r\n            let args = {fileName, fileContent}\r\n\r\n            await super.generateDocumentationAndCache({\r\n                args: args,\r\n                name: fileName,\r\n                pathToFile: file.path,\r\n                folderPath: folder.path,\r\n                sidebarPosition: i,\r\n                sidebarLabel: fileName\r\n            })\r\n        }\r\n\r\n        for (let i = 0; i < folder.folders.length; i++) {\r\n            await this.queryForFolder(folder.folders[i]);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    private cleanDeletedFilesFromCache(folder: FolderStructure) {\r\n        let cachedFiles = DocumentationCache.getByFolderPath(folder.path);\r\n        for (let i=0;i<cachedFiles.length;i++) {\r\n            if (cachedFiles[i].isFolder) continue;\r\n\r\n            let fileExists = false;\r\n            for (let b=0;b<folder.files.length;b++) {\r\n                if (cachedFiles[i].path == folder.files[b].path) {\r\n                    b = folder.files.length;\r\n                    fileExists = true;\r\n                }\r\n            }\r\n            if (!fileExists) {\r\n                console.warn(`Remove file ${cachedFiles[i].path} from cache`)\r\n                DocumentationCache.remove(cachedFiles[i]);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n}\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Files\\FilesBuilder.ts"
	},
	{
		"name": "FoldersBuilder.ts",
		"path": "src\\documentation\\plugins\\builders\\Folders\\FoldersBuilder.ts",
		"folderPath": "src\\documentation\\plugins\\builders\\Folders",
		"fileContent": "import Document from \"../../../Document\";\r\nimport DocumentationCache from \"../../../DocumentationCache\";\r\nimport FolderStructure from \"../../../../utils/FolderStructure\";\r\nimport App from \"../../../../App\";\r\nimport FileStructure from \"../../../../utils/FileStructure\";\r\nimport BaseBuilder from \"../Base/../BaseBuilder\";\r\nimport ProjectStructure from \"../../../../utils/ProjectStructure\";\r\nimport path from \"path\";\r\n\r\n\r\nexport default class FoldersBuilder extends BaseBuilder {\r\n\r\n    constructor(project : any) {\r\n        super('Folders', project);\r\n    }\r\n\r\n    public async generate() {\r\n        let structure = new ProjectStructure();\r\n        let folder = await structure.getStructure();\r\n        await this.queryForFolder(folder, 30);\r\n    }\r\n\r\n    public async queryForFolder(folder: FolderStructure, position: number) {\r\n        //start on the last folder, so we can later build summary of each folder\r\n        for (let i = 0; i < folder.folders.length; i++) {\r\n            await this.queryForFolder(folder.folders[i], i+30);\r\n        }\r\n        let folderName =folder.name;\r\n        if (folder.name = '') {\r\n            folderName = 'Project folder'\r\n        }\r\n\r\n        let document = DocumentationCache.get(folder.path);\r\n        if (!document) {\r\n            let fileAndFolderInfo: any = [];\r\n            folder.files.map(file => {\r\n                fileAndFolderInfo.push({\r\n                    name: file.name,\r\n                    path: file.path,\r\n                    fileOrFolder: 'file',\r\n                    summary: this.getFileSummary(file)\r\n                })\r\n            })\r\n            folder.folders.map((folder) => {\r\n                fileAndFolderInfo.push({\r\n                    name: folder.name,\r\n                    path: folder.path,\r\n                    fileOrFolder: 'folder',\r\n                    summary: this.getFolderSummary(folder)\r\n                })\r\n            })\r\n\r\n            let mdFileName = folderName;\r\n            if (mdFileName == 'src') {\r\n                mdFileName = \"Code\";\r\n            }\r\n            let args = {\r\n                mdFileName,\r\n                repositoryUrl: App.repositoryUrl,\r\n                path: folder.path.replaceAll('\\\\', '/'),\r\n                fileAndFolderInfo: JSON.stringify(fileAndFolderInfo)\r\n            }\r\n            await super.generateDocumentationAndCache({\r\n                    args: args,\r\n                    name: folder.name,\r\n                    pathToFile: folder.path,\r\n                    folderPath: folder.path,\r\n                    saveToPath : folder.path,\r\n                    sidebarPosition: position,\r\n                    sidebarLabel : mdFileName\r\n                }\r\n            )\r\n        }\r\n\r\n\r\n    }\r\n\r\n    public async render(document: Document): Promise<string> {\r\n        return document.documentation;\r\n    }\r\n\r\n\r\n    private getFileSummary(file: FileStructure) {\r\n        let cache = DocumentationCache.get(file.path);\r\n        if (!cache) return '';\r\n\r\n        const regex = /^# .+[\\s\\S]*?^## .+/m;\r\n        const match = regex.exec(cache.documentation);\r\n\r\n        if (match && match[0]) {\r\n            return match[0].trim();\r\n        }\r\n        if (cache.documentation.length> 350) {\r\n            return cache.documentation.substring(0, 350) + '...';\r\n        }\r\n\r\n        return cache.documentation;\r\n\r\n    }\r\n\r\n\r\n    private getFolderSummary(folder: FolderStructure) {\r\n        let cache = DocumentationCache.get(folder.path);\r\n        if (!cache) return '';\r\n\r\n        const regex = /^# .+[\\s\\S]*?^## .+/m;\r\n        const match = regex.exec(cache.documentation);\r\n\r\n        if (match && match[0]) {\r\n            return match[0].trim();\r\n        }\r\n        return '';\r\n    }\r\n\r\n}",
		"documentation": "# FoldersBuilder.ts\n\nThis TypeScript file defines a `FoldersBuilder` class that extends the `BaseBuilder` class. The main purpose of this class is to generate documentation for a given project structure, including folders and files. It also provides methods to query for folder information, render the documentation, and retrieve summaries for files and folders.\n\n## Usage\n\nTo use the `FoldersBuilder` class, you need to import it and create a new instance by passing a `project` object to the constructor. Then, you can call the `generate()` method to generate the documentation.\n\n```typescript\nimport FoldersBuilder from \"./path/to/FoldersBuilder\";\n\nconst project = { /* project data */ };\nconst foldersBuilder = new FoldersBuilder(project);\nawait foldersBuilder.generate();\n```\n\n## Methods\n\n### constructor(project: any)\n\nThe constructor initializes a new instance of the `FoldersBuilder` class with the given `project` object.\n\n- `project`: The project data for which the documentation will be generated.\n\n### async generate()\n\nThis method generates the documentation for the project structure by calling the `queryForFolder()` method.\n\n### async queryForFolder(folder: FolderStructure, position: number)\n\nThis method recursively queries for folder information and generates documentation for each folder and its contents.\n\n- `folder`: A `FolderStructure` object representing the folder to be queried.\n- `position`: The position of the folder in the project structure.\n\n### async render(document: Document): Promise<string>\n\nThis method renders the documentation for a given `Document` object and returns it as a string.\n\n- `document`: A `Document` object containing the documentation to be rendered.\n\n### private getFileSummary(file: FileStructure)\n\nThis method retrieves the summary of a given `FileStructure` object.\n\n- `file`: A `FileStructure` object representing the file for which the summary will be retrieved.\n\n### private getFolderSummary(folder: FolderStructure)\n\nThis method retrieves the summary of a given `FolderStructure` object.\n\n- `folder`: A `FolderStructure` object representing the folder for which the summary will be retrieved.\n\n## Technical Concepts\n\n### FolderStructure and FileStructure\n\nThese are custom classes used to represent the structure of folders and files in the project. They contain properties such as `name`, `path`, and `folders` (for `FolderStructure`) or `files` (for `FileStructure`).\n\n### DocumentationCache\n\nThis is a custom class that manages the caching of documentation data. It provides methods to get and set documentation data in the cache.\n\n### ProjectStructure\n\nThis is a custom class that represents the structure of a project. It provides methods to retrieve the project structure and manipulate it.\n\n### BaseBuilder\n\nThis is the base class for all builder classes, including `FoldersBuilder`. It provides common methods and properties for generating documentation.",
		"isFolder": false,
		"updated": "2023-03-28T12:06:31.135Z",
		"sidebar_position": 0,
		"sidebar_label": "FoldersBuilder.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Folders",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders\\Folders\\FoldersBuilder.ts"
	},
	{
		"name": "PrerequisitesBuilder.ts",
		"path": "src\\documentation\\plugins\\builders\\Prerequisites\\PrerequisitesBuilder.ts",
		"folderPath": "src\\documentation\\plugins\\builders\\Prerequisites",
		"fileContent": "import Document from \"../../../Document\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport ConfigHelper from \"../../../../utils/ConfigHelper\";\r\nimport BaseBuilder from \"../BaseBuilder\";\r\nimport DocumentationCache from \"../../../DocumentationCache\";\r\nimport FileStructure from \"../../../../utils/FileStructure\";\r\n\r\nexport default class PrerequisitesBuilder extends BaseBuilder {\r\n    constructor(project : any) {\r\n        super('Prerequisites', project);\r\n    }\r\n\r\n    public async generate() {\r\n        let document = DocumentationCache.get('Prerequisites')\r\n        if (document) return;\r\n\r\n        let project_path = this.project.project_path;\r\n        const projectFile = FileStructure.getContent(path.join(project_path, this.project.project_file));\r\n\r\n        let args = {projectName : this.project.project_name, projectFile};\r\n        await super.generateDocumentationAndCache({\r\n            args,\r\n            name: \"Prerequisites\",\r\n            pathToFile: './',\r\n            folderPath: './',\r\n            sidebarPosition: 4,\r\n        })\r\n\r\n    }\r\n\r\n    public async render(document: Document) {\r\n        return document.documentation;\r\n    }\r\n}\r\n",
		"documentation": "# PrerequisitesBuilder.ts\n\nThe `PrerequisitesBuilder.ts` file is a TypeScript module that exports a `PrerequisitesBuilder` class. This class is responsible for generating and rendering prerequisite documentation for a given project. It extends the `BaseBuilder` class and utilizes various utility classes and methods to achieve its functionality.\n\n## Usage\n\nTo use the `PrerequisitesBuilder` class, you need to import it and create an instance by passing a `project` object to the constructor. Then, you can call the `generate()` and `render()` methods to generate and render the prerequisite documentation, respectively.\n\n```typescript\nimport PrerequisitesBuilder from \"./PrerequisitesBuilder\";\n\nconst project = { /* project data */ };\nconst prerequisitesBuilder = new PrerequisitesBuilder(project);\n\nawait prerequisitesBuilder.generate();\nconst document = DocumentationCache.get(\"Prerequisites\");\nconst renderedDocumentation = await prerequisitesBuilder.render(document);\n```\n\n## Class Methods\n\n### constructor(project: any)\n\nThe constructor initializes a new instance of the `PrerequisitesBuilder` class. It takes a single parameter:\n\n- `project`: The project object containing the project data.\n\n### generate(): Promise<void>\n\nThe `generate()` method is an asynchronous method that generates the prerequisite documentation for the project. It first checks if the documentation is already cached; if not, it reads the project file, prepares the necessary arguments, and generates the documentation using the `generateDocumentationAndCache()` method from the `BaseBuilder` class.\n\n### render(document: Document): Promise<string>\n\nThe `render()` method is an asynchronous method that takes a `Document` object as a parameter and returns the rendered documentation as a string.\n\n- `document`: The `Document` object containing the documentation data to be rendered.\n\n## Utility Classes and Methods\n\nThe `PrerequisitesBuilder` class makes use of the following utility classes and methods:\n\n- `Document`: A class representing a documentation object.\n- `fs`: The `fs` module from Node.js, used for file system operations.\n- `path`: The `path` module from Node.js, used for handling file and directory paths.\n- `ConfigHelper`: A utility class for handling configuration data.\n- `BaseBuilder`: The base class for all builder classes, providing common functionality.\n- `DocumentationCache`: A class for caching generated documentation.\n- `FileStructure`: A utility class for handling file structures and content.\n\n## Technical Concepts\n\n- **TypeScript**: TypeScript is a superset of JavaScript that adds optional static types, allowing for better tooling and error checking during development.\n- **Asynchronous Methods**: The `generate()` and `render()` methods are asynchronous, meaning they return a `Promise` and can be used with the `await` keyword to wait for their completion before continuing execution.",
		"isFolder": false,
		"updated": "2023-03-28T13:18:32.420Z",
		"sidebar_position": 0,
		"sidebar_label": "PrerequisitesBuilder.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Prerequisites",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"PrerequisitesBuilder.ts\"\r\n\r\n###\r\nIf this is a code file, then\n- Write detailed description for the code that will follow. \n- Give multiple examples of how to use this class before listing each method\n- Create a description for each method in the code. \n- List out the parameters in methods (only if there are any) and write a description for each parameter.\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\n- Divide the document into sections with clear headings and subheadings.\nElse \n- Write detailed description about the file content will follow.\n                    \r\n###\r\n\r\nThis is the content of the file:\r\n###\r\nimport Document from \"../../../Document\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport ConfigHelper from \"../../../../utils/ConfigHelper\";\r\nimport BaseBuilder from \"../BaseBuilder\";\r\nimport DocumentationCache from \"../../../DocumentationCache\";\r\nimport FileStructure from \"../../../../utils/FileStructure\";\r\n\r\nexport default class PrerequisitesBuilder extends BaseBuilder {\r\n    constructor(project : any) {\r\n        super('Prerequisites', project);\r\n    }\r\n\r\n    public async generate() {\r\n        let document = DocumentationCache.get('Prerequisites')\r\n        if (document) return;\r\n\r\n        let project_path = this.project.project_path;\r\n        const projectFile = FileStructure.getContent(path.join(project_path, this.project.project_file));\r\n\r\n        let args = {projectName : this.project.project_name, projectFile};\r\n        await super.generateDocumentationAndCache({\r\n            args,\r\n            name: \"Prerequisites\",\r\n            pathToFile: './',\r\n            folderPath: './',\r\n            sidebarPosition: 4,\r\n        })\r\n\r\n    }\r\n\r\n    public async render(document: Document) {\r\n        return document.documentation;\r\n    }\r\n}\r\n\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Prerequisites\\PrerequisitesBuilder.ts"
	},
	{
		"name": "ReadMeBuilder.ts",
		"path": "src\\documentation\\plugins\\builders\\ReadMe\\ReadMeBuilder.ts",
		"folderPath": "src\\documentation\\plugins\\builders\\ReadMe",
		"fileContent": "import Document from \"../../../Document\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport App from \"../../../../App\";\r\nimport ConfigHelper from \"../../../../utils/ConfigHelper\";\r\nimport BaseBuilder from \"../BaseBuilder\";\r\nimport DocumentationCache from \"../../../DocumentationCache\";\r\nimport FileStructure from \"../../../../utils/FileStructure\";\r\n\r\nexport default class ReadMeBuilder extends BaseBuilder {\r\n    constructor(project : any) {\r\n        super('ReadMe', project);\r\n    }\r\n\r\n    public async generate() {\r\n        let document = DocumentationCache.get('ReadMe');\r\n        if (document) {\r\n            return;\r\n        }\r\n        let projectPath = this.project.project_path;\r\n        let projectFilePath = this.project.project_file;\r\n        const projectFile = FileStructure.getContent(path.join(projectPath, projectFilePath));\r\n        const projectName = ConfigHelper.get('name');\r\n\r\n        let configFilePath = this.project.config_file;\r\n        const configFile = FileStructure.getContent((path.join(projectPath), configFilePath));\r\n\r\n        let entryFile = this.project.entry_file;\r\n        const entryFileContent = FileStructure.getContent((path.join(projectPath), entryFile));\r\n\r\n        let args = {projectName, projectFile, entryFileContent, configFile, repositoryUrl: App.repositoryUrl}\r\n        await super.generateDocumentationAndCache({\r\n            args : args,\r\n            name : 'ReadMe',\r\n            pathToFile: './',\r\n            folderPath: './',\r\n            sidebarPosition : 1,\r\n            sidebarLabel:'Read Me'\r\n        })\r\n    }\r\n\r\n    public async render(document: Document) {\r\n        return document.documentation;\r\n    }\r\n\r\n}",
		"documentation": "# ReadMeBuilder.ts\n\nReadMeBuilder.ts is a TypeScript file that is part of a larger documentation generation system. This class is responsible for generating and rendering the README file for a given project. It extends the BaseBuilder class and utilizes various utility classes and methods to achieve its purpose.\n\n## Usage\n\nTo use the ReadMeBuilder class, you need to import it and create a new instance by passing the project object to the constructor. Then, you can call the `generate()` and `render()` methods to generate and render the README file, respectively.\n\n```typescript\nimport ReadMeBuilder from \"./ReadMeBuilder\";\n\nconst project = { /* project object */ };\nconst readMeBuilder = new ReadMeBuilder(project);\n\nawait readMeBuilder.generate();\nconst document = DocumentationCache.get(\"ReadMe\");\nconst renderedReadMe = await readMeBuilder.render(document);\n```\n\n## Class Methods\n\n### constructor(project: any)\n\nThe constructor initializes a new instance of the ReadMeBuilder class. It takes a single parameter:\n\n- `project`: The project object containing information about the project for which the README file is being generated.\n\n### generate()\n\nThis asynchronous method generates the README file for the project. It first checks if the README document is already cached; if not, it proceeds to gather the necessary information from the project and calls the `generateDocumentationAndCache()` method from the BaseBuilder class.\n\n### render(document: Document)\n\nThis asynchronous method renders the README file using the provided document object. It takes a single parameter:\n\n- `document`: A Document object containing the documentation content to be rendered.\n\nIt returns the rendered documentation as a string.\n\n## Technical Concepts\n\n### FileStructure\n\nThe FileStructure utility class is used to interact with the file system and retrieve the content of files. It is used in the `generate()` method to read the content of the project file, config file, and entry file.\n\n### ConfigHelper\n\nThe ConfigHelper utility class is used to retrieve configuration values from the project. In this case, it is used to get the project name.\n\n### DocumentationCache\n\nThe DocumentationCache class is responsible for caching generated documentation. It is used in the `generate()` method to check if the README document is already cached and in the example usage to retrieve the generated README document.\n\n### App\n\nThe App class contains global information about the application. In this case, it is used to get the repository URL.\n\n## Sections\n\n- [Usage](#usage)\n- [Class Methods](#class-methods)\n  - [constructor(project: any)](#constructorproject-any)\n  - [generate()](#generate)\n  - [render(document: Document)](#renderdocument-document)\n- [Technical Concepts](#technical-concepts)\n  - [FileStructure](#filestructure)\n  - [ConfigHelper](#confighelper)\n  - [DocumentationCache](#documentationcache)\n  - [App](#app)",
		"isFolder": false,
		"updated": "2023-03-28T11:30:26.687Z",
		"sidebar_position": 0,
		"sidebar_label": "ReadMeBuilder.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\ReadMe",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders\\ReadMe\\ReadMeBuilder.ts"
	},
	{
		"name": "UsageBuilder.ts",
		"path": "src\\documentation\\plugins\\builders\\Usage\\UsageBuilder.ts",
		"folderPath": "src\\documentation\\plugins\\builders\\Usage",
		"fileContent": "import Document from \"../../../Document\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport ConfigHelper from \"../../../../utils/ConfigHelper\";\r\nimport BaseBuilder from \"../BaseBuilder\";\r\nimport DocumentationCache from \"../../../DocumentationCache\";\r\nimport FileStructure from \"../../../../utils/FileStructure\";\r\n\r\nexport default class UsageBuilder extends BaseBuilder {\r\n    constructor(project : any) {\r\n        super('Usage', project);\r\n    }\r\n\r\n    public async generate() {\r\n        let document = DocumentationCache.get('Usage')\r\n        if (document) return;\r\n\r\n        let project_path = this.project.project_path;\r\n        const projectFile = FileStructure.getContent(path.join(project_path, this.project.project_file));\r\n        const cliFile = FileStructure.getContent(path.join(project_path, this.project.cli_file ?? this.project.entry_file));\r\n        const configFile = FileStructure.getContent(path.join(project_path, this.project.config_file));\r\n\r\n        let args = {projectName : this.project.project_name, projectFile, cliFile, configFile};\r\n        await super.generateDocumentationAndCache({\r\n            args,\r\n            name: \"Usage\",\r\n            pathToFile: './',\r\n            folderPath: './',\r\n            sidebarPosition: 5,\r\n            sidebarLabel: 'Usage'\r\n        })\r\n\r\n    }\r\n\r\n    public async render(document: Document) {\r\n        return document.documentation;\r\n    }\r\n}\r\n",
		"documentation": "# UsageBuilder.ts\n\n## Overview\n\nThe `UsageBuilder.ts` file is a TypeScript module that exports a `UsageBuilder` class, which extends the `BaseBuilder` class. This class is responsible for generating and caching usage documentation for a given project. It also provides a method to render the documentation.\n\n## Class: UsageBuilder\n\n### Constructor\n\n```typescript\nconstructor(project: any)\n```\n\nThe constructor takes a single parameter, `project`, which is an object containing the project's information. It initializes the `UsageBuilder` instance by calling the `super` constructor with the `'Usage'` type and the `project` object.\n\n### Method: generate\n\n```typescript\npublic async generate()\n```\n\nThe `generate` method is an asynchronous function that generates and caches the usage documentation for the project. It first checks if the documentation is already cached, and if so, it returns immediately. Otherwise, it reads the project's files, such as the project file, CLI file, and config file, and constructs an `args` object containing the project's name and file contents. It then calls the `generateDocumentationAndCache` method from the `BaseBuilder` class to generate and cache the documentation.\n\n### Method: render\n\n```typescript\npublic async render(document: Document)\n```\n\nThe `render` method is an asynchronous function that takes a `Document` object as its parameter and returns the documentation content.\n\n## Usage\n\nTo use the `UsageBuilder` class, you need to import it and create an instance with the project information. Then, you can call the `generate` method to generate and cache the usage documentation, and the `render` method to render the documentation.\n\n```typescript\nimport UsageBuilder from \"./UsageBuilder\";\n\nconst projectInfo = {\n  project_path: \"path/to/project\",\n  project_file: \"projectFile.ts\",\n  cli_file: \"cliFile.ts\",\n  config_file: \"configFile.ts\",\n  project_name: \"MyProject\",\n};\n\nconst usageBuilder = new UsageBuilder(projectInfo);\nawait usageBuilder.generate();\nconst document = DocumentationCache.get(\"Usage\");\nconst renderedDocumentation = await usageBuilder.render(document);\n```\n\n## Dependencies\n\nThe `UsageBuilder.ts` file imports several dependencies:\n\n- `Document`: A class representing a documentation object.\n- `fs`: The Node.js file system module, used for reading files.\n- `path`: The Node.js path module, used for joining and manipulating file paths.\n- `ConfigHelper`: A utility class for working with configuration files.\n- `BaseBuilder`: The base class for all builder classes, providing common functionality.\n- `DocumentationCache`: A class for caching documentation objects.\n- `FileStructure`: A utility class for working with file structures.",
		"isFolder": false,
		"updated": "2023-03-28T11:31:32.832Z",
		"sidebar_position": 0,
		"sidebar_label": "UsageBuilder.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Usage",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders\\Usage\\UsageBuilder.ts"
	},
	{
		"name": "Behaviour",
		"path": "src\\documentation\\plugins\\builders\\Behaviour",
		"folderPath": "src\\documentation\\plugins\\builders\\Behaviour",
		"fileContent": "",
		"documentation": "# Behaviour\n\nThis folder is responsible for managing the behaviour of the system. It contains files and folders that define and implement various aspects of the system's functionality.\n\n## Sections\n\n### BehaviourBuilder.ts\n\nThe `BehaviourBuilder.ts` file is responsible for constructing the behaviour of the system. It provides an overview of the system's functionality and how it interacts with other components.\n\n[BehaviourBuilder.ts Documentation](BehaviourBuilder.ts)\n\n## Repository\n\nFor more information and the complete source code, visit the [repository](https://github.com/ingig/code-narrator/src/documentation/plugins/builders/Behaviour).",
		"isFolder": true,
		"updated": "2023-03-28T11:32:53.778Z",
		"sidebar_position": 30,
		"sidebar_label": "Behaviour",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation\\plugins\\builders\\Behaviour",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders\\Behaviour"
	},
	{
		"name": "Files",
		"path": "src\\documentation\\plugins\\builders\\Files",
		"folderPath": "src\\documentation\\plugins\\builders\\Files",
		"fileContent": "",
		"documentation": "# Files\n\nThis folder is responsible for managing the documentation generation process for the given files and folders in the system. It contains the necessary components to extract, format, and present the information in a clear and organized manner.\n\n## Sections\n\n### FilesBuilder.ts\n\n- [FilesBuilder.ts](FilesBuilder.ts)\n\n#### Overview\n\nThe `FilesBuilder.ts` file is responsible for building the documentation for the files and folders in the system. It takes the input JSON data and generates high-level information for each file and folder, without providing any code examples. This file is essential for creating a well-structured and easy-to-navigate documentation.\n\n## Repository\n\nFor more information and to access the source code, visit the [repository](https://github.com/ingig/code-narrator/src/documentation/plugins/builders/Files).",
		"isFolder": true,
		"updated": "2023-03-28T11:33:44.834Z",
		"sidebar_position": 32,
		"sidebar_label": "Files",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation\\plugins\\builders\\Files",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders\\Files"
	},
	{
		"name": "Folders",
		"path": "src\\documentation\\plugins\\builders\\Folders",
		"folderPath": "src\\documentation\\plugins\\builders\\Folders",
		"fileContent": "",
		"documentation": "# Folders\n\nThis folder is responsible for managing the documentation generation process for various files and folders within the system. It contains a single file, `FoldersBuilder.ts`, which handles the core functionality of building the documentation structure.\n\n## FoldersBuilder.ts\n\n### Overview\n\n`FoldersBuilder.ts` is a file that contains the main logic for generating documentation based on the provided JSON data. It is responsible for dividing the document into sections with clear headings and subheadings, listing each file and folder in its own section, and linking each section to its own documentation.\n\n[**FoldersBuilder.ts Documentation**](FoldersBuilder.ts)\n\n---\n\n[**Back to Repository**](https://github.com/ingig/code-narrator/src/documentation/plugins/builders/Folders)",
		"isFolder": true,
		"updated": "2023-03-28T11:34:05.662Z",
		"sidebar_position": 33,
		"sidebar_label": "Folders",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation\\plugins\\builders\\Folders",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders\\Folders"
	},
	{
		"name": "Prerequisites",
		"path": "src\\documentation\\plugins\\builders\\Prerequisites",
		"folderPath": "src\\documentation\\plugins\\builders\\Prerequisites",
		"fileContent": "",
		"documentation": "# Prerequisites\n\nThis folder is responsible for managing the prerequisites in the system. It contains files and folders that help in building and maintaining the prerequisites for the documentation.\n\n## Sections\n\n### PrerequisitesBuilder.ts\n\n- [PrerequisitesBuilder.ts](#prerequisitesbuilderts)\n\n#### PrerequisitesBuilder.ts\n\nThe `PrerequisitesBuilder.ts` file is located at `src\\documentation\\plugins\\builders\\Prerequisites\\PrerequisitesBuilder.ts`. This file is responsible for building the prerequisites for the documentation.\n\n##### Overview\n\nThe `PrerequisitesBuilder.ts` file contains the necessary functions and classes to manage the prerequisites in the system. It helps in generating the required prerequisites for the documentation.\n\n[Link to PrerequisitesBuilder.ts documentation](PrerequisitesBuilder.ts)\n\n## Repository\n\nFor more information and to access the source code, visit the repository at [https://github.com/ingig/code-narrator/src/documentation/plugins/builders/Prerequisites](https://github.com/ingig/code-narrator/src/documentation/plugins/builders/Prerequisites).",
		"isFolder": true,
		"updated": "2023-03-28T11:34:29.590Z",
		"sidebar_position": 34,
		"sidebar_label": "Prerequisites",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation\\plugins\\builders\\Prerequisites",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders\\Prerequisites"
	},
	{
		"name": "ReadMe",
		"path": "src\\documentation\\plugins\\builders\\ReadMe",
		"folderPath": "src\\documentation\\plugins\\builders\\ReadMe",
		"fileContent": "",
		"documentation": "# ReadMe\n\nThis folder is responsible for generating and rendering the README file for a given project as part of a larger documentation generation system. The content is divided into sections with clear headings and subheadings, providing high-level information about each file and folder.\n\n## Files and Folders\n\n### [ReadMeBuilder.ts](ReadMeBuilder.ts)\n\nReadMeBuilder.ts is a TypeScript file that is part of a larger documentation generation system. This class is responsible for generating and rendering the README file for a given project. It extends the BaseBuilder class and utilizes various utility classes and methods to achieve its purpose.\n\n#### Usage\n\nFor more information on how to use ReadMeBuilder.ts, please refer to its [documentation](ReadMeBuilder.ts).\n\n## Repository\n\nFor more information and resources, visit the [repository](https://github.com/ingig/code-narrator/src/documentation/plugins/builders/ReadMe).",
		"isFolder": true,
		"updated": "2023-03-28T11:34:53.390Z",
		"sidebar_position": 35,
		"sidebar_label": "ReadMe",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation\\plugins\\builders\\ReadMe",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders\\ReadMe"
	},
	{
		"name": "Usage",
		"path": "src\\documentation\\plugins\\builders\\Usage",
		"folderPath": "src\\documentation\\plugins\\builders\\Usage",
		"fileContent": "",
		"documentation": "# Usage\n\nThis folder is responsible for generating documentation for the system based on the provided JSON content. The documentation is divided into sections with clear headings and subheadings, providing high-level information about each file and folder.\n\n## Sections\n\n### UsageBuilder.ts\n\n[UsageBuilder.ts](src\\documentation\\plugins\\builders\\Usage\\UsageBuilder.ts) is a file responsible for building the usage documentation.\n\n#### Overview\n\nThe UsageBuilder.ts file is responsible for generating the documentation based on the provided JSON content. It does not include any code examples but provides high-level information about the system.\n\nFor more information, refer to the [UsageBuilder.ts documentation](src\\documentation\\plugins\\builders\\Usage\\UsageBuilder.ts).\n\n## Repository\n\nFor the complete repository, visit [https://github.com/ingig/code-narrator/src/documentation/plugins/builders/Usage](https://github.com/ingig/code-narrator/src/documentation/plugins/builders/Usage).",
		"isFolder": true,
		"updated": "2023-03-28T11:35:16.198Z",
		"sidebar_position": 36,
		"sidebar_label": "Usage",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation\\plugins\\builders\\Usage",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders\\Usage"
	},
	{
		"name": "Project folder",
		"path": "",
		"folderPath": "",
		"fileContent": "",
		"documentation": "# Project folder\n\nThis documentation provides an in-depth overview of the contents of the project folder and their respective roles in the system. The folder is divided into sections with clear headings and subheadings.\n\n## Table of Contents\n\n- [code-narrator.config.ts](#code-narratorconfigts)\n- [jest.config.js](#jestconfigjs)\n- [package.json](#packagejson)\n- [tsconfig.json](#tsconfigjson)\n- [src](#src)\n- [__tests__](#__tests__)\n\n### code-narrator.config.ts\n\nThis file contains the configuration settings for the Code Narrator documentation generator. It imports various builder and generator plugins and sets up the project structure and settings for generating documentation.\n\n[Link to code-narrator.config.ts documentation](code-narrator.config.ts)\n\n### jest.config.js\n\nThis file contains the configuration settings for the Jest testing framework used in the project.\n\n[Link to jest.config.js documentation](jest.config.js)\n\n### package.json\n\nThis file contains the project's metadata, such as its name, version, and dependencies. It also includes scripts that can be run to perform various tasks, such as building, testing, and deploying the project.\n\n[Link to package.json documentation](package.json)\n\n### tsconfig.json\n\nThe `tsconfig.json` file is a configuration file for TypeScript projects. It specifies the root files and the compiler options required to compile the project. This file is used by the TypeScript compiler (`tsc`) to guide the compilation process and generate the desired JavaScript output.\n\n[Link to tsconfig.json documentation](tsconfig.json)\n\n### src\n\nThis folder contains the source code for the project. It is organized into subfolders and files that each have a specific purpose within the system.\n\n[Link to src folder documentation](src)\n\n### __tests__\n\nThe `__tests__` folder is responsible for containing all the test files and related resources for the system. This documentation provides an in-depth overview of the content of this folder, divided into sections with clear headings and subheadings.\n\n[Link to __tests__ folder documentation](__tests__)\n\n---\n\n[Link to repository](https://github.com/ingig/code-narrator/)",
		"isFolder": true,
		"updated": "2023-03-28T12:02:40.816Z",
		"sidebar_position": 30,
		"sidebar_label": "Project folder",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": ".",
		"documentation_type": "md",
		"id": ""
	},
	{
		"name": "src",
		"path": "src",
		"folderPath": "src",
		"fileContent": "",
		"documentation": "# Code\n\nThis documentation provides an in-depth overview of the contents of the folder and their respective roles in the system. The folder is divided into sections with clear headings and subheadings.\n\n## Table of Contents\n\n- [App.ts](#appts)\n- [cli.ts](#clits)\n- [Documentation](#documentation)\n- [Repositories](#repositories)\n- [Utils](#utils)\n\n### App.ts\n\nThis file contains the main class `App` and its implementation for the code-narrator application. The code-narrator application is used to generate documentation for a project by analyzing its code and folder structure, and then using GPT to generate documentation in markdown format.\n\n[App.ts Documentation](App.ts)\n\n### cli.ts\n\nThis file contains the command line interface for the code-narrator application. It is responsible for parsing command line arguments and executing the appropriate actions based on the user's input.\n\n[cli.ts Documentation](cli.ts)\n\n### Documentation\n\nThis folder contains the necessary files and classes to generate documentation for a project by analyzing its code and folder structure, and then using GPT to generate documentation in markdown format.\n\n[Documentation Folder Documentation](documentation)\n\n### Repositories\n\nThis folder contains the necessary files and classes to interact with various APIs and services. The main purpose of this folder is to provide a centralized location for managing data access and communication with external services.\n\n[Repositories Folder Documentation](repositories)\n\n### Utils\n\nThe `utils` folder is responsible for providing various utility functions and classes that can be used throughout the system. This folder contains the following files:\n\n- [ConfigHelper.ts](#confighelperts)\n- [FileStructure.ts](#filestructurets)\n- [FolderStructure.ts](#folderstructurets)\n- [Helper.ts](#helperts)\n- [ProjectStructure.ts](#projectstructurets)\n\n[Utils Folder Documentation](utils)\n\n## Repository Link\n\n[Code Narrator Repository](https://github.com/ingig/code-narrator/src)",
		"isFolder": true,
		"updated": "2023-03-28T11:50:31.093Z",
		"sidebar_position": 30,
		"sidebar_label": "Code",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src",
		"documentation_type": "md",
		"id": "src"
	},
	{
		"name": "builders",
		"path": "src\\documentation\\plugins\\builders",
		"folderPath": "src\\documentation\\plugins\\builders",
		"fileContent": "",
		"documentation": "# builders\n\nThis folder is responsible for managing the documentation generation process for various files and folders within the system. The content is divided into sections with clear headings and subheadings, providing high-level information about each file and folder.\n\n## Sections\n\n### [BaseBuilder.ts](BaseBuilder.ts)\n\n#### Overview\n\n### [Behaviour](Behaviour)\n\nThis folder is responsible for managing the behaviour of the system. It contains files and folders that define and implement various aspects of the system's functionality.\n\n#### Sections\n\n### [Configuration](Configuration)\n\nThis folder is responsible for generating documentation for configuration files in a project. It contains the `ConfigurationBuilder` class, which extends the `BaseBuilder` class and provides methods to generate documentation for app-specific and general configuration files, as well as updating the summary of configuration files.\n\n#### Sections\n\n### [Files](Files)\n\nThis folder is responsible for managing the documentation generation process for the given files and folders in the system. It contains the necessary components to extract, format, and present the information in a clear and organized manner.\n\n#### Sections\n\n### [Folders](Folders)\n\nThis folder is responsible for managing the documentation generation process for various files and folders within the system. It contains a single file, `FoldersBuilder.ts`, which handles the core functionality of building the documentation structure.\n\n#### [FoldersBuilder.ts](FoldersBuilder.ts)\n\n### [Prerequisites](Prerequisites)\n\nThis folder is responsible for managing the prerequisites in the system. It contains files and folders that help in building and maintaining the prerequisites for the documentation.\n\n#### Sections\n\n### [ReadMe](ReadMe)\n\nThis folder is responsible for generating and rendering the README file for a given project as part of a larger documentation generation system. The content is divided into sections with clear headings and subheadings, providing high-level information about each file and folder.\n\n#### Files and Folders\n\n### [Usage](Usage)\n\nThis folder is responsible for generating documentation for the system based on the provided JSON content. The documentation is divided into sections with clear headings and subheadings, providing high-level information about each file and folder.\n\n#### Sections\n\n[Link to repository](https://github.com/ingig/code-narrator/src/documentation/plugins/builders)",
		"isFolder": true,
		"updated": "2023-03-28T12:00:39.603Z",
		"sidebar_position": 30,
		"sidebar_label": "builders",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation\\plugins\\builders",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders"
	},
	{
		"name": "generators",
		"path": "src\\documentation\\plugins\\generators",
		"folderPath": "src\\documentation\\plugins\\generators",
		"fileContent": "",
		"documentation": "# generators\n\nThis folder is responsible for managing the generator plugins used to parse the documentation and modify it for the build tool you are using to build the documentation. The default plugin with code-narrator is Docusaurus since it fails to build when a function contains a `Promise<>` in return. This plugin clears that Promise from the function name so it can build. It also creates sidebar information.\n\n## [BaseGenerator.ts](BaseGenerator.ts)\n\n`BaseGenerator.ts` is a TypeScript code file that defines the base class for Generator plugins. Generator plugins are used to parse the documentation and modify it for the build tool you are using to build the documentation.\n\n### Usage\n\nFor more information on how to use `BaseGenerator.ts`, please refer to its [documentation](BaseGenerator.ts).\n\n## [Docusaurus](Docusaurus)\n\nThis folder is responsible for generating documentation compatible with Docusaurus, a popular static site generator for documentation websites. The content of this folder includes the following files and folders:\n\n### [DocusaurusGenerator.ts](Docusaurus/DocusaurusGenerator.ts)\n\nFor more information on how to use `DocusaurusGenerator.ts`, please refer to its [documentation](Docusaurus/DocusaurusGenerator.ts).\n\n---\n\n[Link to repository](https://github.com/ingig/code-narrator/src/documentation/plugins/generators)",
		"isFolder": true,
		"updated": "2023-03-28T12:01:16.300Z",
		"sidebar_position": 31,
		"sidebar_label": "generators",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation\\plugins\\generators",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\generators"
	},
	{
		"name": "plugins",
		"path": "src\\documentation\\plugins",
		"folderPath": "src\\documentation\\plugins",
		"fileContent": "",
		"documentation": "# plugins\n\nThis folder is responsible for managing the documentation generation process for various files and folders within the system. The content is divided into sections with clear headings and subheadings, providing high-level information about each file and folder.\n\n## [GenerateOptions.ts](GenerateOptions.ts)\n\n### Overview\n\n## [builders](builders)\n\nThis folder is responsible for managing the documentation generation process for various files and folders within the system. The content is divided into sections with clear headings and subheadings, providing high-level information about each file and folder.\n\n### Sections\n\n## [generators](generators)\n\nThis folder is responsible for managing the generator plugins used to parse the documentation and modify it for the build tool you are using to build the documentation. The default plugin with code-narrator is Docusaurus since it fails to build when a function contains a `Promise<>` in return. This plugin clears that Promise from the function name so it can build. It also creates sidebar information.\n\n### [BaseGenerator.ts](BaseGenerator.ts)\n\n[Repository](https://github.com/ingig/code-narrator/src/documentation/plugins)",
		"isFolder": true,
		"updated": "2023-03-28T12:01:44.958Z",
		"sidebar_position": 30,
		"sidebar_label": "plugins",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation\\plugins",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins"
	},
	null,
	{
		"name": "",
		"path": "src\\documentation\\plugins\\builders\\Configuration",
		"folderPath": "src\\documentation\\plugins\\builders\\Configuration",
		"fileContent": "",
		"documentation": "# Configuration\n\nThis folder is responsible for generating documentation for configuration files in a project. It contains the `ConfigurationBuilder` class, which extends the `BaseBuilder` class and provides methods to generate documentation for app-specific and general configuration files, as well as updating the summary of configuration files.\n\n## Sections\n\n### [ConfigurationBuilder.ts](ConfigurationBuilder.ts)\n\nThis file contains the `ConfigurationBuilder` class, which is responsible for generating documentation for configuration files in a project. It extends the `BaseBuilder` class and provides methods to generate documentation for app-specific and general configuration files, as well as updating the summary of configuration files.\n\n#### Usage\n\nFor more information on how to use the `ConfigurationBuilder` class, please refer to the [ConfigurationBuilder.ts](ConfigurationBuilder.ts) documentation.\n\n## Repository\n\nFor more information and the source code, visit the [repository](https://github.com/ingig/code-narrator/src/documentation/plugins/builders/Configuration).",
		"isFolder": true,
		"updated": "2023-03-28T12:16:28.357Z",
		"sidebar_position": 31,
		"sidebar_label": "Configuration",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "src\\documentation\\plugins\\builders\\Configuration",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders\\Configuration"
	},
	{
		"name": "BehaviourBuilder.ts",
		"path": "src\\documentation\\plugins\\builders\\Behaviour\\BehaviourBuilder.ts",
		"folderPath": "src\\documentation\\plugins\\builders\\Behaviour",
		"fileContent": "import Document from \"../../../Document\";\r\nimport fs from \"fs\";\r\nimport path from \"path\";\r\nimport ConfigHelper from \"../../../../utils/ConfigHelper\";\r\nimport BaseBuilder from \"../BaseBuilder\";\r\nimport DocumentationCache from \"../../../DocumentationCache\";\r\n\r\nexport default class BehaviourBuilder extends BaseBuilder {\r\n    constructor(project : any) {\r\n        super('Behaviour', project);\r\n    }\r\n\r\n    public async generate() {\r\n        let document = DocumentationCache.get('Behaviour')\r\n        if (document) return;\r\n\r\n        let project_path = ConfigHelper.get('project_path')\r\n        let entry_file = ConfigHelper.get('entry_file');\r\n        const entryFile = fs.readFileSync(path.join(project_path, entry_file));\r\n\r\n        let args = {entryFile};\r\n        await super.generateDocumentationAndCache({\r\n            args,\r\n            name: \"Behaviour\",\r\n            pathToFile: './',\r\n            folderPath: './',\r\n            sidebarPosition: 2,\r\n            sidebarLabel: 'Behaviour'\r\n        })\r\n\r\n    }\r\n\r\n    public async render(document: Document) {\r\n        return document.documentation;\r\n    }\r\n}\r\n",
		"documentation": "# BehaviourBuilder.ts\n\n`BehaviourBuilder.ts` is a TypeScript code file that is responsible for generating and rendering documentation for the \"Behaviour\" section of a project. It extends the `BaseBuilder` class and utilizes the `DocumentationCache` and `ConfigHelper` utilities to manage the documentation generation process.\n\n## Usage\n\nTo use the `BehaviourBuilder` class, you need to import it and create a new instance by passing the `project` object to the constructor. Then, you can call the `generate()` and `render()` methods to generate and render the documentation for the \"Behaviour\" section.\n\n```typescript\nimport BehaviourBuilder from \"./BehaviourBuilder\";\n\nconst project = { /* project data */ };\nconst behaviourBuilder = new BehaviourBuilder(project);\n\nawait behaviourBuilder.generate();\nconst document = DocumentationCache.get(\"Behaviour\");\nconst renderedDocumentation = await behaviourBuilder.render(document);\n```\n\n## Class: BehaviourBuilder\n\n### Constructor: `constructor(project: any)`\n\nThe constructor takes a single parameter:\n\n- `project`: The project object for which the documentation is being generated.\n\n### Method: `generate()`\n\nThis asynchronous method generates the documentation for the \"Behaviour\" section and caches it using the `DocumentationCache`. It reads the project's entry file and generates the documentation using the `generateDocumentationAndCache()` method from the `BaseBuilder` class.\n\n### Method: `render(document: Document)`\n\nThis asynchronous method takes a `Document` object as a parameter and returns the rendered documentation.\n\n- `document`: A `Document` object containing the documentation to be rendered.\n\n## Technical Concepts\n\n### DocumentationCache\n\n`DocumentationCache` is a utility class that helps manage the caching of generated documentation. It provides methods to store and retrieve documentation, ensuring that the documentation generation process is efficient and avoids unnecessary regeneration.\n\n### ConfigHelper\n\n`ConfigHelper` is a utility class that helps manage the configuration settings for the project. It provides methods to get and set configuration values, making it easy to access and modify the project's settings.\n\n### BaseBuilder\n\n`BaseBuilder` is an abstract class that provides the foundation for generating and managing documentation. It includes methods for generating documentation, caching it, and rendering it. The `BehaviourBuilder` class extends `BaseBuilder` to provide specific functionality for the \"Behaviour\" section of the documentation.",
		"isFolder": false,
		"updated": "2023-03-28T12:33:04.150Z",
		"sidebar_position": 0,
		"sidebar_label": "BehaviourBuilder.ts",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Behaviour",
		"documentation_type": "md",
		"id": "src\\documentation\\plugins\\builders\\Behaviour\\BehaviourBuilder.ts"
	},
	{
		"name": "Configuration",
		"path": "Configuration",
		"folderPath": "./Configuration",
		"fileContent": "",
		"documentation": "The app-specific config file you provided is `code-narrator.config.ts`. This configuration file is used to set up the Code Narrator documentation generation tool. It defines the project settings, builder plugins, generator plugins, and other configurations required for generating documentation in the desired format.\n\nHere's an example of usage for the app-specific configs:\n\n```typescript\nimport CodeNarrator from \"code-narrator\";\n\nconst config = require(\"./code-narrator.config.ts\");\n\nconst codeNarrator = new CodeNarrator(config);\ncodeNarrator.generateDocumentation();\n```\n\nIn this example, the `code-narrator.config.ts` file is imported and used to create a new instance of the Code Narrator tool. The `generateDocumentation()` method is then called to generate the documentation based on the provided configuration.\n\nAs for the other configuration files you mentioned:\n\n1. `jest.config.js`: This is a configuration file for Jest, a popular JavaScript testing framework. It contains settings and options related to running tests, such as test environment, test coverage, and mocking.\n\n2. `package.json`: This is a standard configuration file for Node.js projects. It contains metadata about the project, such as name, version, description, and dependencies. It also includes scripts that can be run using the `npm` command.\n\n3. `tsconfig.json`: This is a configuration file for TypeScript, a typed superset of JavaScript. It contains settings and options related to TypeScript compilation, such as target JavaScript version, module resolution, and type checking options.\n\n:::note\nRemember to format any extracted text according to the requested format (in this case, Markdown) and replace any secret information with *****.\n:::",
		"isFolder": true,
		"updated": "2023-03-28T14:44:56.931Z",
		"sidebar_position": 3,
		"sidebar_label": "Configuration",
		"init": false,
		"postInit": false,
		"generator": "Configuration",
		"saveToPath": "./Configuration",
		"documentation_type": "md",
		"question": "This is (or are) the app-specific config file(s) for .\r\nGive me a detailed description, and what their purpose is in the application if you can decide.\r\nGive an example of usage for the app-specific configs\r\n###\r\ncode-narrator.config.ts\r\n###\r\n\r\nHere is the content of the app specific config file(s)\r\n###\r\n--- Start code-narrator.config.ts ---\n            // code-narrator.config.ts\r\nimport ConfigurationBuilder from \"./src/documentation/plugins/builders/Configuration/ConfigurationBuilder\";\r\nimport FilesBuilder from \"./src/documentation/plugins/builders/Files/FilesBuilder\";\r\nimport FoldersBuilder from \"./src/documentation/plugins/builders/Folders/FoldersBuilder\";\r\nimport ReadMeBuilder from \"./src/documentation/plugins/builders/ReadMe/ReadMeBuilder\";\r\nimport BehaviourBuilder from \"./src/documentation/plugins/builders/Behaviour/BehaviourBuilder\";\r\nimport DocusaurusGenerator from \"./src/documentation/plugins/generators/Docusaurus/DocusaurusGenerator\";\r\nimport PrerequisitesBuilder from \"./src/documentation/plugins/builders/Prerequisites/PrerequisitesBuilder\";\r\nimport UsageBuilder from \"./src/documentation/plugins/builders/Usage/UsageBuilder\";\r\n\r\nexport default {\r\n    projects : [{\r\n        project_file: \"package.json\",\r\n        config_file: \"code-narrator.config.ts\", //if you have specific app config file, e.g. for code-narrator, \"code-narrator.config.ts\" is the app config file\r\n        entry_file: \"./src/App.ts\",\r\n        cli_file:\"./src/cli.ts\",\r\n        project_path: \"./\",\r\n        source_path: \"./src\",\r\n        documentation_path: \"./docs\",\r\n        test_path: \"./test\",\r\n        exclude : ['ReadMe.md', '/node_modules', '/docs', '/test', '/__test__/**', '.env', '/.idea', '/.git',\r\n            '.gitignore', '/.code-narrator', '/classic', '/build', 'package-lock.json'],\r\n        readmeRoot : true\r\n    }],\r\n    //Order of plugins matter, ConfigurationGenerator runs first to get overview of the project.\r\n    builderPlugins : [\r\n        ConfigurationBuilder, PrerequisitesBuilder, UsageBuilder, FilesBuilder, FoldersBuilder, ReadMeBuilder, BehaviourBuilder\r\n    ],\r\n    generatorPlugin : [\r\n        DocusaurusGenerator\r\n    ],\r\n    gptSystemCommands : [\r\n        'If there is :::note, :::info, :::caution, :::tip, :::danger in the text, extract that from its location and format it correctly',\r\n        `Return your answer in {DocumentationType} format`,\r\n        `If you notice any secret information, replace it with ***** in your response`\r\n    ],\r\n    documentation_type: 'md', //What format should be generated, e.g. md, sphinx\r\n    document_file_extension: \".md\",\r\n    cache_file : '.code-narrator/cache.json' //location of the cache file. :::warning '.code-narrator/cache.json' should be committed into git.\r\n};\r\n\n            --- End code-narrator.config.ts ---\n            \r\n###\r\n\r\nThese are other configuration files, give short general information about each of them, but only if you recognize them.\r\nIf you do not recognize them, then don't mention the config\r\n###\r\njest.config.js\npackage.json\ntsconfig.json\r\n###\r\n",
		"id": "Configuration",
		"data": {
			"appSpecificConfigFiles": [
				"code-narrator.config.ts"
			],
			"configFiles": [
				"jest.config.js",
				"package.json",
				"tsconfig.json"
			]
		}
	},
	{
		"name": "gpt_question.liquid",
		"path": "src\\documentation\\plugins\\builders\\Files\\gpt_question.liquid",
		"folderPath": "src\\documentation\\plugins\\builders\\Files",
		"fileContent": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"{{fileName}}\"\r\nThe file name is: {{ fileName }}\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\n{{fileContent}}\r\n###\r\n",
		"documentation": "# gpt_question.liquid\n\nThis is a template file that provides a structure for generating in-depth documentation about a given file. The template uses Liquid, a templating language that allows you to embed dynamic content within a static text file.\n\n## Variables used in the template file\n\n- `fileName`: The name of the file for which the documentation is being generated.\n- `fileContent`: The content of the file for which the documentation is being generated.\n\n## Template file content\n\n```\n###\nAct as a documentation expert. Write in-depth documentation about following file.\nHeadline of file should be \"{{fileName}}\"\nThe file name is: {{ fileName }}\nIf this is a code file, then\n- Write a detailed description of the code that will follow.\n- Give multiple examples of how to use this class before listing each method\n- Create a description for each method in the code.\n- List out the parameters in methods (only if there are any) and describe each parameter.\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\n- Divide the document into sections with clear headings and subheadings.\nIf this is a template file\n- List the variables that are used in the template file\n- Display the template file\nElse\n- Write a detailed description of the file content that will follow.\n\nThis is the content of the file:\n###\n{{fileContent}}\n###\n```\n\nThis template file provides a structure for generating documentation for a given file. It includes conditional statements to handle different types of files (code files, template files, or other file types) and provides guidelines for documenting various aspects of the file, such as descriptions, examples, methods, parameters, and technical concepts. The template also includes placeholders for the file name and content, which will be replaced with the actual values when the template is rendered.",
		"isFolder": false,
		"updated": "2023-03-28T14:01:09.991Z",
		"sidebar_position": 1,
		"sidebar_label": "gpt_question.liquid",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Files",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"gpt_question.liquid\"\r\nThe file name is: gpt_question.liquid\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nAct as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"{{fileName}}\"\r\nThe file name is: {{ fileName }}\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\n{{fileContent}}\r\n###\r\n\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Files\\gpt_question.liquid"
	},
	{
		"name": "gpt_question.liquid",
		"path": "src\\documentation\\plugins\\builders\\Behaviour\\gpt_question.liquid",
		"folderPath": "src\\documentation\\plugins\\builders\\Behaviour",
		"fileContent": "Give a deep in-depth description of the behavior of the application.\r\nI provide you with high-level description of what the application does\r\nand the source for starting the application\r\nHeadline of file should be \"Behaviour\"\r\nDo not describe the code in this file in your writing, only use it as a reference to help you write about the application's behavior.\r\n\r\nFile with application description comment:\r\n###\r\n{{entryFile}}\r\n###",
		"documentation": "# gpt_question.liquid\n\nThis is a template file that provides a high-level description of an application's behavior. The template file uses variables to display the entry file and the headline of the file.\n\n## Variables used in the template file\n\n- `entryFile`: The source file for starting the application.\n\n## Template file content\n\n```\n###\nGive a deep in-depth description of the behavior of the application.\nI provide you with high-level description of what the application does\nand the source for starting the application\nHeadline of file should be \"Behaviour\"\nDo not describe the code in this file in your writing, only use it as a reference to help you write about the application's behavior.\n\nFile with application description comment:\n###\n{{entryFile}}\n###\n###\n```\n\nWhen using this template file, replace the `{{entryFile}}` variable with the appropriate file name or path to display the source file for starting the application. The template will then provide a high-level description of the application's behavior, without delving into the code itself.",
		"isFolder": false,
		"updated": "2023-03-28T14:45:27.822Z",
		"sidebar_position": 1,
		"sidebar_label": "gpt_question.liquid",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Behaviour",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"gpt_question.liquid\"\r\nThe file name is: gpt_question.liquid\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nGive a deep in-depth description of the behavior of the application.\r\nI provide you with high-level description of what the application does\r\nand the source for starting the application\r\nHeadline of file should be \"Behaviour\"\r\nDo not describe the code in this file in your writing, only use it as a reference to help you write about the application's behavior.\r\n\r\nFile with application description comment:\r\n###\r\n{{entryFile}}\r\n###\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Behaviour\\gpt_question.liquid"
	},
	{
		"name": "app_config.liquid",
		"path": "src\\documentation\\plugins\\builders\\Configuration\\app_config.liquid",
		"folderPath": "src\\documentation\\plugins\\builders\\Configuration",
		"fileContent": "These are the app-specific config files called {{fileName}}.\r\nWhen you use {{ projectName }} in your project, you need set these configurations correctly to match your project.\r\nGive me a detailed description of them, and what their purpose is in the application if you can decide.\r\nGive example on how to retrieve from the config file\r\n###\r\n{{ configFile }}\r\n###",
		"documentation": "# app_config.liquid\n\n## Overview\n\nThe `app_config.liquid` file is a template file that contains app-specific configuration settings for a project using {{ projectName }}. These settings are crucial for the proper functioning of the application and must be set correctly to match your project requirements.\n\nThe purpose of this configuration file is to store various settings and parameters that can be easily accessed and modified throughout the application. This allows for better organization and maintainability of the codebase.\n\n## Variables\n\nThe following variables are used in the `app_config.liquid` template file:\n\n- `fileName`: The name of the app-specific config file.\n- `projectName`: The name of the project using {{ projectName }}.\n- `configFile`: The content of the app-specific config file.\n\n## Template File\n\nBelow is the content of the `app_config.liquid` template file:\n\n```\n###\nThese are the app-specific config files called {{fileName}}.\nWhen you use {{ projectName }} in your project, you need set these configurations correctly to match your project.\nGive me a detailed description of them, and what their purpose is in the application if you can decide.\nGive example on how to retrieve from the config file\n###\n{{ configFile }}\n###\n```\n\n## Retrieving Configuration Values\n\nTo retrieve a value from the `app_config.liquid` file, you can use the following syntax:\n\n```liquid\n{% assign config_value = configFile.variable_name %}\n```\n\nReplace `variable_name` with the name of the variable you want to retrieve from the configuration file.\n\nFor example, if you have a variable called `api_key` in your `app_config.liquid` file, you can retrieve its value like this:\n\n```liquid\n{% assign api_key = configFile.api_key %}\n```\n\nNow you can use the `api_key` variable in your application as needed.\n\n## Conclusion\n\nThe `app_config.liquid` file is an essential part of any project using {{ projectName }}. It allows developers to store and manage app-specific configuration settings in a centralized location, making it easier to maintain and update the application. By understanding the variables used in this template file and how to retrieve configuration values, you can effectively work with the `app_config.liquid` file in your projects.",
		"isFolder": false,
		"updated": "2023-03-28T14:10:45.835Z",
		"sidebar_position": 0,
		"sidebar_label": "app_config.liquid",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Configuration",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"app_config.liquid\"\r\nThe file name is: app_config.liquid\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nThese are the app-specific config files called {{fileName}}.\r\nWhen you use {{ projectName }} in your project, you need set these configurations correctly to match your project.\r\nGive me a detailed description of them, and what their purpose is in the application if you can decide.\r\nGive example on how to retrieve from the config file\r\n###\r\n{{ configFile }}\r\n###\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Configuration\\app_config.liquid"
	},
	{
		"name": "general_config.liquid",
		"path": "src\\documentation\\plugins\\builders\\Configuration\\general_config.liquid",
		"folderPath": "src\\documentation\\plugins\\builders\\Configuration",
		"fileContent": "This is a configuration file that is meant for developers of {{ projectName }}.\r\nIf you are using {{ projectName }} as a package in your project this file is irrelevant.\r\nAct as a documentation expert. Write detailed description of this configuration file\r\n###\r\n{{ configFile }}\r\n###",
		"documentation": "# general_config.liquid\n\n## Overview\n\nThe `general_config.liquid` file is a configuration file specifically designed for developers working on the {{ projectName }}. This file is not relevant for users who are simply using {{ projectName }} as a package in their projects. The purpose of this configuration file is to provide a centralized location for managing various settings and configurations related to the development environment and build process.\n\n## Template Variables\n\nThe following variables are used in the `general_config.liquid` template file:\n\n- `{{ projectName }}`: Represents the name of the project that this configuration file is associated with.\n- `{{ configFile }}`: Represents the content of the configuration file.\n\n## Configuration File Content\n\nThe content of the `general_config.liquid` file is displayed below:\n\n```\n###\nThis is a configuration file that is meant for developers of {{ projectName }}.\nIf you are using {{ projectName }} as a package in your project this file is irrelevant.\nAct as a documentation expert. Write detailed description of this configuration file\n###\n{{ configFile }}\n###\n```\n\n### Description\n\nThe `general_config.liquid` file begins with a comment block that provides a brief overview of the file's purpose and its intended audience. It states that the file is meant for developers of {{ projectName }} and is not relevant for users who are using {{ projectName }} as a package in their projects.\n\nFollowing the comment block, the `{{ configFile }}` variable is used to display the actual content of the configuration file. This content may include various settings and configurations related to the development environment, build process, and other aspects of the project.\n\n### Usage\n\nDevelopers working on {{ projectName }} should refer to the `general_config.liquid` file for information on the project's configuration settings and update the file as needed to reflect changes in the development environment or build process. Users who are using {{ projectName }} as a package in their projects can safely ignore this file, as it does not affect the functionality of the package.\n\n## Conclusion\n\nThe `general_config.liquid` file is an essential part of the {{ projectName }} development process, providing a centralized location for managing various settings and configurations. By understanding the purpose and content of this file, developers can more effectively manage their development environment and build process, ensuring a smoother and more efficient development experience.",
		"isFolder": false,
		"updated": "2023-03-28T14:11:44.391Z",
		"sidebar_position": 2,
		"sidebar_label": "general_config.liquid",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Configuration",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"general_config.liquid\"\r\nThe file name is: general_config.liquid\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nThis is a configuration file that is meant for developers of {{ projectName }}.\r\nIf you are using {{ projectName }} as a package in your project this file is irrelevant.\r\nAct as a documentation expert. Write detailed description of this configuration file\r\n###\r\n{{ configFile }}\r\n###\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Configuration\\general_config.liquid"
	},
	{
		"name": "gpt_question.liquid",
		"path": "src\\documentation\\plugins\\builders\\Configuration\\gpt_question.liquid",
		"folderPath": "src\\documentation\\plugins\\builders\\Configuration",
		"fileContent": "This is (or are) the app-specific config file(s) for {{ projectName }}.\r\nGive me a detailed description, and what their purpose is in the application if you can decide.\r\nGive an example of usage for the app-specific configs\r\n###\r\n{{appSpecificConfigFiles}}\r\n###\r\n\r\nHere is the content of the app specific config file(s)\r\n###\r\n{{appSpecificConfigContent}}\r\n###\r\n\r\nThese are other configuration files, give short general information about each of them, but only if you recognize them.\r\nIf you do not recognize them, then don't mention the config\r\n###\r\n{{configFiles}}\r\n###\r\n",
		"documentation": "# gpt_question.liquid\n\nThe `gpt_question.liquid` file is a template file that provides a structured format for displaying information about app-specific configuration files, their content, and other related configuration files in a project.\n\n## Variables used in the template file\n\nThe following variables are used in the `gpt_question.liquid` template file:\n\n1. `projectName`: The name of the project for which the app-specific configuration files are being described.\n2. `appSpecificConfigFiles`: A list of app-specific configuration files used in the project.\n3. `appSpecificConfigContent`: The content of the app-specific configuration files.\n4. `configFiles`: A list of other configuration files that may be related to the project.\n\n## Template file display\n\n```\n###\nThis is (or are) the app-specific config file(s) for {{ projectName }}.\nGive me a detailed description, and what their purpose is in the application if you can decide.\nGive an example of usage for the app-specific configs\n###\n{{appSpecificConfigFiles}}\n###\n\nHere is the content of the app specific config file(s)\n###\n{{appSpecificConfigContent}}\n###\n\nThese are other configuration files, give short general information about each of them, but only if you recognize them.\nIf you do not recognize them, then don't mention the config\n###\n{{configFiles}}\n###\n```\n\n## Example usage\n\nSuppose we have a project named \"MyApp\" with the following app-specific configuration files and content:\n\n- `app_config.json`: Contains settings related to the app's behavior and appearance.\n- `database_config.yaml`: Contains settings related to the app's database connection and schema.\n\nThe `gpt_question.liquid` template file can be used to generate the following documentation:\n\n```\n###\nThis is (or are) the app-specific config file(s) for MyApp.\nGive me a detailed description, and what their purpose is in the application if you can decide.\nGive an example of usage for the app-specific configs\n###\n- app_config.json\n- database_config.yaml\n###\n\nHere is the content of the app specific config file(s)\n###\n{\n  \"app_name\": \"MyApp\",\n  \"theme_color\": \"#123456\",\n  \"api_key\": \"*****\"\n}\n---\ndb:\n  host: \"localhost\"\n  port: 5432\n  user: \"myapp_user\"\n  password: \"*****\"\n  database: \"myapp_db\"\n###\n```\n\nIn this example, the `app_config.json` file contains settings related to the app's behavior and appearance, such as the app's name, theme color, and API key. The `database_config.yaml` file contains settings related to the app's database connection and schema, such as the host, port, user, password, and database name. Note that sensitive information like API keys and passwords are replaced with asterisks (*****).",
		"isFolder": false,
		"updated": "2023-03-28T14:13:17.823Z",
		"sidebar_position": 3,
		"sidebar_label": "gpt_question.liquid",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Configuration",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"gpt_question.liquid\"\r\nThe file name is: gpt_question.liquid\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nThis is (or are) the app-specific config file(s) for {{ projectName }}.\r\nGive me a detailed description, and what their purpose is in the application if you can decide.\r\nGive an example of usage for the app-specific configs\r\n###\r\n{{appSpecificConfigFiles}}\r\n###\r\n\r\nHere is the content of the app specific config file(s)\r\n###\r\n{{appSpecificConfigContent}}\r\n###\r\n\r\nThese are other configuration files, give short general information about each of them, but only if you recognize them.\r\nIf you do not recognize them, then don't mention the config\r\n###\r\n{{configFiles}}\r\n###\r\n\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Configuration\\gpt_question.liquid"
	},
	{
		"name": "what_are_config_files.liquid",
		"path": "src\\documentation\\plugins\\builders\\Configuration\\what_are_config_files.liquid",
		"folderPath": "src\\documentation\\plugins\\builders\\Configuration",
		"fileContent": "The name of the app is \"{{appName}}\", of this list of files and folders, what do you consider as being config files\r\n\r\n{{listOfFilesAndFolders}}\r\n\r\nReturn this information in JSON.\r\nIn the json there should be a property, isConfig: true or false.\r\nFind one or more config that is applications specific config file(s) then add property isAppSpecific: true, else false.\r\n\r\nThis is the json scheme:\r\n[ { \"path\":\"\"folder/fileName\"\", \"isConfig\":bool, \"isAppSpecific\": bool }, { ... } ]",
		"documentation": "# What Are Config Files\n\nThis documentation is about the template file `what_are_config_files.liquid`. The file is designed to help identify and categorize configuration files in a given list of files and folders. The template file uses variables and returns the information in JSON format.\n\n## Variables\n\nThe template file uses the following variables:\n\n- `appName`: The name of the app.\n- `listOfFilesAndFolders`: A list of files and folders to be analyzed.\n\n## Template File Content\n\nThe content of the `what_are_config_files.liquid` file is as follows:\n\n```\n###\nThe name of the app is \"{{appName}}\", of this list of files and folders, what do you consider as being config files\n\n{{listOfFilesAndFolders}}\n\nReturn this information in JSON.\nIn the json there should be a property, isConfig: true or false.\nFind one or more config that is applications specific config file(s) then add property isAppSpecific: true, else false.\n\nThis is the json scheme:\n[ { \"path\":\"\"folder/fileName\"\", \"isConfig\":bool, \"isAppSpecific\": bool }, { ... } ]\n###\n```\n\nThe file provides instructions on how to identify and categorize configuration files. The output should be in JSON format, with each file represented as an object containing the following properties:\n\n- `path`: The path of the file or folder.\n- `isConfig`: A boolean value indicating whether the file is a configuration file (true) or not (false).\n- `isAppSpecific`: A boolean value indicating whether the configuration file is specific to the given app (true) or not (false).\n\nThe JSON schema for the output is as follows:\n\n```\n[\n  {\n    \"path\": \"folder/fileName\",\n    \"isConfig\": bool,\n    \"isAppSpecific\": bool\n  },\n  { ... }\n]\n```\n\nThis template file can be used to analyze a list of files and folders, identify configuration files, and categorize them based on their relevance to a specific app.",
		"isFolder": false,
		"updated": "2023-03-28T14:14:20.030Z",
		"sidebar_position": 4,
		"sidebar_label": "what_are_config_files.liquid",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Configuration",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"what_are_config_files.liquid\"\r\nThe file name is: what_are_config_files.liquid\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nThe name of the app is \"{{appName}}\", of this list of files and folders, what do you consider as being config files\r\n\r\n{{listOfFilesAndFolders}}\r\n\r\nReturn this information in JSON.\r\nIn the json there should be a property, isConfig: true or false.\r\nFind one or more config that is applications specific config file(s) then add property isAppSpecific: true, else false.\r\n\r\nThis is the json scheme:\r\n[ { \"path\":\"\"folder/fileName\"\", \"isConfig\":bool, \"isAppSpecific\": bool }, { ... } ]\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Configuration\\what_are_config_files.liquid"
	},
	{
		"name": "gpt_question.liquid",
		"path": "src\\documentation\\plugins\\builders\\Folders\\gpt_question.liquid",
		"folderPath": "src\\documentation\\plugins\\builders\\Folders",
		"fileContent": "Act as a documentation expert. Write in-depth documentation about the content of this folder.\r\n\r\nHeader of the file should be \"{{ mdFileName }}\".\r\nAfter the header, use the json content provided to generate description of what this folder is responsible for doing in the system\r\nDivide the document into sections with clear headings and subheadings.\r\n\r\nList each file and folder into its own section.\r\nWrite high level information in each section, DO NOT generate code examples.\r\nLink each section to its own documentation. The format of the link is simply the name of the folder or file.\r\n\r\nAt the end of the file add link to repository, the url is {{ repositoryUrl }}/{{ path }}\r\n\r\nHere is json of the data your need\r\n###\r\n{{ fileAndFolderInfo }}\r\n###",
		"documentation": "# gpt_question.liquid\n\nThis is a template file that generates in-depth documentation about the content of a folder. The template uses variables and JSON data to create a structured and detailed description of the folder's purpose and its contents.\n\n## Variables used in the template file\n\n- `mdFileName`: The name of the Markdown file that will be generated.\n- `fileAndFolderInfo`: JSON data containing information about the files and folders in the directory.\n- `repositoryUrl`: The URL of the repository where the folder is located.\n- `path`: The path to the folder within the repository.\n\n## Template file content\n\n```\n###\nAct as a documentation expert. Write in-depth documentation about the content of this folder.\n\nHeader of the file should be \"{{ mdFileName }}\".\nAfter the header, use the json content provided to generate a description of what this folder is responsible for doing in the system\nDivide the document into sections with clear headings and subheadings.\n\nList each file and folder into its own section.\nWrite high level information in each section, DO NOT generate code examples.\nLink each section to its own documentation. The format of the link is simply the name of the folder or file.\n\nAt the end of the file add a link to the repository, the url is {{ repositoryUrl }}/{{ path }}\n\nHere is the json of the data you need\n###\n{{ fileAndFolderInfo }}\n###\n```\n\nThis template file will generate a Markdown file with the specified `mdFileName` as its header. It will then use the provided JSON data (`fileAndFolderInfo`) to create a description of the folder's purpose and responsibilities within the system.\n\nThe template will divide the document into sections with clear headings and subheadings, listing each file and folder in its own section. High-level information will be provided for each section, without generating code examples.\n\nEach section will be linked to its own documentation, using the folder or file name as the link format. Finally, a link to the repository will be added at the end of the file, using the `repositoryUrl` and `path` variables.",
		"isFolder": false,
		"updated": "2023-03-28T14:15:25.275Z",
		"sidebar_position": 1,
		"sidebar_label": "gpt_question.liquid",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Folders",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"gpt_question.liquid\"\r\nThe file name is: gpt_question.liquid\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nAct as a documentation expert. Write in-depth documentation about the content of this folder.\r\n\r\nHeader of the file should be \"{{ mdFileName }}\".\r\nAfter the header, use the json content provided to generate description of what this folder is responsible for doing in the system\r\nDivide the document into sections with clear headings and subheadings.\r\n\r\nList each file and folder into its own section.\r\nWrite high level information in each section, DO NOT generate code examples.\r\nLink each section to its own documentation. The format of the link is simply the name of the folder or file.\r\n\r\nAt the end of the file add link to repository, the url is {{ repositoryUrl }}/{{ path }}\r\n\r\nHere is json of the data your need\r\n###\r\n{{ fileAndFolderInfo }}\r\n###\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Folders\\gpt_question.liquid"
	},
	{
		"name": "gpt_question.liquid",
		"path": "src\\documentation\\plugins\\builders\\Prerequisites\\gpt_question.liquid",
		"folderPath": "src\\documentation\\plugins\\builders\\Prerequisites",
		"fileContent": "Provide information on Prerequisites for a project called {{ projectName }}.\r\nList any required software, tools, or knowledge needed to work with or understand the project.\r\n\r\nThis is the project file\r\n\r\n###\r\n{{ projectFile }}\r\n###",
		"documentation": "# gpt_question.liquid\n\nThis is a template file for providing information on prerequisites for a project called `{{ projectName }}`. The template file is written in Liquid, a templating language used in various web frameworks and content management systems.\n\n## Variables\n\nThe template file uses the following variables:\n\n- `{{ projectName }}`: The name of the project for which the prerequisites are being provided.\n- `{{ projectFile }}`: The content of the project file.\n\n## Template File Content\n\nBelow is the content of the `gpt_question.liquid` template file:\n\n```\n###\nProvide information on Prerequisites for a project called {{ projectName }}.\nList any required software, tools, or knowledge needed to work with or understand the project.\n\nThis is the project file\n\n###\n{{ projectFile }}\n###\n```\n\n### Usage\n\nTo use this template file, you need to replace the `{{ projectName }}` and `{{ projectFile }}` variables with the appropriate values for your specific project. The template will then generate a formatted text with the prerequisites and project file information.\n\nFor example, if you have a project called \"MyProject\" and the content of the project file is \"This is a sample project file\", you would replace the variables as follows:\n\n```\n###\nProvide information on Prerequisites for a project called MyProject.\nList any required software, tools, or knowledge needed to work with or understand the project.\n\nThis is the project file\n\n###\nThis is a sample project file\n###\n```\n\nThe resulting output would be:\n\n```\nProvide information on Prerequisites for a project called MyProject.\nList any required software, tools, or knowledge needed to work with or understand the project.\n\nThis is the project file\n\nThis is a sample project file\n```",
		"isFolder": false,
		"updated": "2023-03-28T14:16:13.586Z",
		"sidebar_position": 0,
		"sidebar_label": "gpt_question.liquid",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Prerequisites",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"gpt_question.liquid\"\r\nThe file name is: gpt_question.liquid\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nProvide information on Prerequisites for a project called {{ projectName }}.\r\nList any required software, tools, or knowledge needed to work with or understand the project.\r\n\r\nThis is the project file\r\n\r\n###\r\n{{ projectFile }}\r\n###\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Prerequisites\\gpt_question.liquid"
	},
	{
		"name": "gpt_question.liquid",
		"path": "src\\documentation\\plugins\\builders\\ReadMe\\gpt_question.liquid",
		"folderPath": "src\\documentation\\plugins\\builders\\ReadMe",
		"fileContent": "Create a \"ReadMe\" guide for the project, named \"{{ projectName }}\".\r\nFrom the description of the project file describe the purpose of the project and the idea of it.\r\nShow current version.\r\nShow how to install the project.\r\nShow how to configure the project from the config file, if there is any configuration\r\nShow how to run the project.\r\nShow how to run tests for the project\r\nShow where to post bugs, what the homepage of the project is and link to repository ({{ repositoryUrl }}), if available. Do not repeat the same url.\r\nList the dependencies at the end of file.\r\n\r\nThis is the entry file:\r\n###\r\n{{ entryFileContent }}\r\n###\r\n\r\nThis is the config file:\r\n###\r\n{{ configFile }}\r\n###\r\n\r\nThis is the project file:\r\n###\r\n{{ projectFile }}\r\n###",
		"documentation": "# gpt_question.liquid\n\nThis is a template file used to generate a \"ReadMe\" guide for a project. The template file uses variables to customize the content based on the specific project details.\n\n## Variables used in the template file\n\n- `projectName`: The name of the project.\n- `repositoryUrl`: The URL of the project's repository.\n- `entryFileContent`: The content of the project's entry file.\n- `configFile`: The content of the project's configuration file.\n- `projectFile`: The content of the project's main file.\n\n## Template file content\n\n```\nCreate a \"ReadMe\" guide for the project, named \"{{ projectName }}\".\nFrom the description of the project file describe the purpose of the project and the idea of it.\nShow current version.\nShow how to install the project.\nShow how to configure the project from the config file, if there is any configuration\nShow how to run the project.\nShow how to run tests for the project\nShow where to post bugs, what the homepage of the project is and link to repository ({{ repositoryUrl }}), if available. Do not repeat the same url.\nList the dependencies at the end of file.\n\nThis is the entry file:\n###\n{{ entryFileContent }}\n###\n\nThis is the config file:\n###\n{{ configFile }}\n###\n\nThis is the project file:\n###\n{{ projectFile }}\n###\n```\n\nThe template file will generate a \"ReadMe\" guide for the project with the following sections:\n\n1. Project name and description\n2. Current version\n3. Installation instructions\n4. Configuration instructions (if applicable)\n5. Running the project\n6. Running tests\n7. Bug reporting, project homepage, and repository URL\n8. Dependencies\n9. Entry file content\n10. Configuration file content\n11. Project file content",
		"isFolder": false,
		"updated": "2023-03-28T14:46:27.018Z",
		"sidebar_position": 0,
		"sidebar_label": "gpt_question.liquid",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\ReadMe",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"gpt_question.liquid\"\r\nThe file name is: gpt_question.liquid\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nCreate a \"ReadMe\" guide for the project, named \"{{ projectName }}\".\r\nFrom the description of the project file describe the purpose of the project and the idea of it.\r\nShow current version.\r\nShow how to install the project.\r\nShow how to configure the project from the config file, if there is any configuration\r\nShow how to run the project.\r\nShow how to run tests for the project\r\nShow where to post bugs, what the homepage of the project is and link to repository ({{ repositoryUrl }}), if available. Do not repeat the same url.\r\nList the dependencies at the end of file.\r\n\r\nThis is the entry file:\r\n###\r\n{{ entryFileContent }}\r\n###\r\n\r\nThis is the config file:\r\n###\r\n{{ configFile }}\r\n###\r\n\r\nThis is the project file:\r\n###\r\n{{ projectFile }}\r\n###\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\ReadMe\\gpt_question.liquid"
	},
	{
		"name": "gpt_question.liquid",
		"path": "src\\documentation\\plugins\\builders\\Usage\\gpt_question.liquid",
		"folderPath": "src\\documentation\\plugins\\builders\\Usage",
		"fileContent": "Provide step-by-step instructions for using the code-narrator library in my own project by installing the package and running it.\r\n\r\nTo run code-narrator in cli, you run code-narrator-cli\r\n\r\nThis is the config file the user needs to create (using code-narrator-cli init) and modify to fit his project,\r\nthis will include change to config_file, project_file, entry_file, cli_file and any paths that doesn´t match the user project\r\n\r\n###\r\n{{ configFile }}\r\n###",
		"documentation": "# gpt_question.liquid\n\n## Overview\n\nThis is a template file that provides instructions for using the code-narrator library in your own project. The template file contains variables that need to be replaced with the appropriate values for your specific project.\n\n## Variables\n\nThe following variables are used in the template file:\n\n- `configFile`: The configuration file that the user needs to create and modify to fit their project.\n\n## Template File Content\n\nBelow is the content of the gpt_question.liquid template file:\n\n```\n###\nProvide step-by-step instructions for using the code-narrator library in my own project by installing the package and running it.\n\nTo run code-narrator in cli, you run code-narrator-cli\n\nThis is the config file the user needs to create (using code-narrator-cli init) and modify to fit his project,\nthis will include change to config_file, project_file, entry_file, cli_file and any paths that doesn´t match the user project\n\n###\n{{ configFile }}\n###\n###\n```\n\n## Usage\n\nTo use this template file, replace the `{{ configFile }}` variable with the appropriate configuration file content for your project. Then, follow the step-by-step instructions provided in the template to install and run the code-narrator library in your project.",
		"isFolder": false,
		"updated": "2023-03-28T14:17:50.603Z",
		"sidebar_position": 0,
		"sidebar_label": "gpt_question.liquid",
		"init": false,
		"postInit": false,
		"generator": "Files",
		"saveToPath": "src\\documentation\\plugins\\builders\\Usage",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about following file.\r\nHeadline of file should be \"gpt_question.liquid\"\r\nThe file name is: gpt_question.liquid\r\nIf this is a code file, then\r\n- Write a detailed description of the code that will follow.\r\n- Give multiple examples of how to use this class before listing each method\r\n- Create a description for each method in the code.\r\n- List out the parameters in methods (only if there are any) and describe each parameter.\r\n- Explain technical concepts that are not standard but come apparent in the code. Example of a standard concept is JSON.\r\n- Divide the document into sections with clear headings and subheadings.\r\nIf this is a template file\r\n- List the variables that are used in the template file\r\n- Display the template file\r\nElse\r\n- Write a detailed description of the file content that will follow.\r\n\r\nThis is the content of the file:\r\n###\r\nProvide step-by-step instructions for using the code-narrator library in my own project by installing the package and running it.\r\n\r\nTo run code-narrator in cli, you run code-narrator-cli\r\n\r\nThis is the config file the user needs to create (using code-narrator-cli init) and modify to fit his project,\r\nthis will include change to config_file, project_file, entry_file, cli_file and any paths that doesn´t match the user project\r\n\r\n###\r\n{{ configFile }}\r\n###\r\n###\r\n",
		"id": "src\\documentation\\plugins\\builders\\Usage\\gpt_question.liquid"
	},
	{
		"name": "",
		"path": "__tests__",
		"folderPath": "__tests__",
		"fileContent": "",
		"documentation": "# __tests__\n\nThis document provides an in-depth description of the content of the `__tests__` folder. The folder is responsible for various aspects of the system, and its content is divided into sections with clear headings and subheadings.\n\n## [logic](#__tests__\\logic)\n\nThis folder is responsible for handling the logic of the system. It contains files and folders that are essential for the proper functioning of the system. The content of this folder is described in the following sections.\n\n### [SuggestionBuilderTest.ts](#__tests__\\logic\\SuggestionBuilderTest.ts)\n\nThis file contains tests for the SuggestionBuilder, which is responsible for generating suggestions based on user input and system data.\n\n## [repositories](#__tests__\\repositories)\n\nThis folder contains various repositories that are responsible for handling different aspects of the system. Each repository has its own set of responsibilities and interacts with different APIs or services.\n\n### Table of Contents\n\n- [SuggestionBuilderTest.ts](#__tests__\\logic\\SuggestionBuilderTest.ts)\n\nFor more information, visit the [repository](https://github.com/ingig/code-narrator/__tests__).",
		"isFolder": true,
		"updated": "2023-03-28T14:18:21.323Z",
		"sidebar_position": 31,
		"sidebar_label": "__tests__",
		"init": false,
		"postInit": false,
		"generator": "Folders",
		"saveToPath": "__tests__",
		"documentation_type": "md",
		"question": "Act as a documentation expert. Write in-depth documentation about the content of this folder.\r\n\r\nHeader of the file should be \"__tests__\".\r\nAfter the header, use the json content provided to generate description of what this folder is responsible for doing in the system\r\nDivide the document into sections with clear headings and subheadings.\r\n\r\nList each file and folder into its own section.\r\nWrite high level information in each section, DO NOT generate code examples.\r\nLink each section to its own documentation. The format of the link is simply the name of the folder or file.\r\n\r\nAt the end of the file add link to repository, the url is https://github.com/ingig/code-narrator/__tests__\r\n\r\nHere is json of the data your need\r\n###\r\n[{\"name\":\"\",\"path\":\"__tests__\\\\logic\",\"fileOrFolder\":\"folder\",\"summary\":\"# logic\\n\\nThis folder is responsible for handling the logic of the system. It contains files and folders that are essential for the proper functioning of the system. The content of this folder is described in the following sections.\\n\\n## SuggestionBuilderTest.ts\"},{\"name\":\"\",\"path\":\"__tests__\\\\repositories\",\"fileOrFolder\":\"folder\",\"summary\":\"# Repositories\\n\\nThis folder contains various repositories that are responsible for handling different aspects of the system. Each repository has its own set of responsibilities and interacts with different APIs or services.\\n\\n## Table of Contents\"}]\r\n###",
		"id": "__tests__"
	}
]